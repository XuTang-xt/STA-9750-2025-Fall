[
  {
    "objectID": "mp01.html",
    "href": "mp01.html",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "",
    "text": "This report, written entirely in English, uses Netflix’s public Top 10 weekly data to answer the assignment’s exploratory questions (Q1–Q10) and drafts three press releases: (1) Stranger Things, (2) the Indian market, and (3) a free‑topic “debut week global hit.” All computations are reproducible—just render this Quarto document in R/RStudio. The code creates a data/mp01/ folder and downloads the latest TSV files directly from Netflix.\n\nTip: Key numbers are injected via inline R code; tables are interactive via DT::datatable(); numbers are formatted with thousand separators for readability."
  },
  {
    "objectID": "mp01.html#q1.-how-many-countries-does-netflix-operate-in-as-represented-in-the-dataset",
    "href": "mp01.html#q1.-how-many-countries-does-netflix-operate-in-as-represented-in-the-dataset",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q1. How many countries does Netflix operate in (as represented in the dataset)?",
    "text": "Q1. How many countries does Netflix operate in (as represented in the dataset)?\n\n\nCode\ncountries &lt;- COUNTRY_TOP_10 |&gt;\n  distinct(country) |&gt;\n  arrange(country)\nn_countries &lt;- nrow(countries)\nn_countries\n\n\n[1] 94\n\n\nNetflix Top 10 covers 94 countries/regions."
  },
  {
    "objectID": "mp01.html#q2.-among-films-nonenglish-which-title-has-the-highest-cumulative-weeks-in-the-global-top-10",
    "href": "mp01.html#q2.-among-films-nonenglish-which-title-has-the-highest-cumulative-weeks-in-the-global-top-10",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q2. Among Films (Non‑English), which title has the highest cumulative weeks in the Global Top 10?",
    "text": "Q2. Among Films (Non‑English), which title has the highest cumulative weeks in the Global Top 10?\n\n\nCode\nq2_tbl &lt;- GLOBAL_TOP_10 |&gt;\n  filter(category == \"Films (Non-English)\") |&gt;\n  group_by(show_title) |&gt;\n  summarise(total_weeks = max(cumulative_weeks_in_top_10, na.rm = TRUE), .groups=\"drop\") |&gt;\n  arrange(desc(total_weeks)) |&gt;\n  slice_head(n = 10)\nbest_noneng_film &lt;- q2_tbl$show_title[1]\nbest_noneng_weeks &lt;- q2_tbl$total_weeks[1]\nDT::datatable(q2_tbl, options = list(searching=FALSE, info=FALSE)) |&gt;\n  DT::formatRound(\"total_weeks\", 0)\n\n\n\n\n\n\nAnswer: All Quiet on the Western Front with 23 weeks."
  },
  {
    "objectID": "mp01.html#q3.-what-is-the-longestruntime-film-minutes-that-ever-entered-the-global-top-10",
    "href": "mp01.html#q3.-what-is-the-longestruntime-film-minutes-that-ever-entered-the-global-top-10",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q3. What is the longest‑runtime film (minutes) that ever entered the Global Top 10?",
    "text": "Q3. What is the longest‑runtime film (minutes) that ever entered the Global Top 10?\n\n\nCode\nq3_tbl &lt;- GLOBAL_TOP_10 |&gt;\n  filter(str_detect(category, \"^Films\")) |&gt;\n  mutate(runtime_minutes = round(60 * runtime)) |&gt;\n  group_by(show_title) |&gt;\n  summarise(max_runtime = max(runtime_minutes, na.rm = TRUE), .groups=\"drop\") |&gt;\n  arrange(desc(max_runtime)) |&gt;\n  slice_head(n=10)\nlongest_title &lt;- q3_tbl$show_title[1]\nlongest_min   &lt;- q3_tbl$max_runtime[1]\nDT::datatable(q3_tbl, options = list(searching=FALSE, info=FALSE))\n\n\n\n\n\n\nAnswer: Pushpa 2: The Rule (Reloaded Version) (~224 minutes). (Note: early entries may have missing runtime.)"
  },
  {
    "objectID": "mp01.html#q4.-within-each-of-the-four-categories-which-title-has-the-largest-global-total-hours-viewed",
    "href": "mp01.html#q4.-within-each-of-the-four-categories-which-title-has-the-largest-global-total-hours-viewed",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q4. Within each of the four categories, which title has the largest global total hours viewed?",
    "text": "Q4. Within each of the four categories, which title has the largest global total hours viewed?\n\n\nCode\nq4_tbl &lt;- GLOBAL_TOP_10 |&gt;\n  group_by(category, show_title) |&gt;\n  summarise(total_hours = sum(weekly_hours_viewed, na.rm = TRUE), .groups=\"drop\") |&gt;\n  group_by(category) |&gt;\n  slice_max(order_by = total_hours, n = 1, with_ties = FALSE) |&gt;\n  ungroup() |&gt;\n  arrange(category)\n\nDT::datatable(q4_tbl |&gt;\n                 mutate(total_hours = scales::comma(total_hours)),\n               options = list(searching=FALSE, info=FALSE)) |&gt;\n  DT::formatStyle(\"total_hours\", target = \"row\", fontWeight = \"bold\")"
  },
  {
    "objectID": "mp01.html#q5.-which-tv-title-stayed-in-a-single-countrys-top-10-for-the-most-weeks-report-the-title-country-and-length.",
    "href": "mp01.html#q5.-which-tv-title-stayed-in-a-single-countrys-top-10-for-the-most-weeks-report-the-title-country-and-length.",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q5. Which TV title stayed in a single country’s Top 10 for the most weeks? Report the title, country, and length.",
    "text": "Q5. Which TV title stayed in a single country’s Top 10 for the most weeks? Report the title, country, and length.\n\n\nCode\nq5_tbl &lt;- COUNTRY_TOP_10 |&gt;\n  filter(str_detect(category, \"^TV\")) |&gt;\n  arrange(country, show_title, week, weekly_rank) |&gt;\n  group_by(country, show_title) |&gt;\n  summarise(weeks_in_top10 = n_distinct(week), .groups=\"drop\") |&gt;\n  arrange(desc(weeks_in_top10)) |&gt;\n  slice_head(n=15)\n\nq5_top      &lt;- q5_tbl |&gt; slice(1)\nq5_title    &lt;- q5_top$show_title\nq5_country  &lt;- q5_top$country\nq5_weeks    &lt;- q5_top$weeks_in_top10\n\nDT::datatable(q5_tbl, options = list(searching=TRUE, pageLength=10))\n\n\n\n\n\n\nAnswer: Money Heist in Pakistan for 128 weeks."
  },
  {
    "objectID": "mp01.html#q6.-identify-the-country-with-only-200-weeks-i.e.-a-short-run-in-the-dataset-and-when-its-data-ended.",
    "href": "mp01.html#q6.-identify-the-country-with-only-200-weeks-i.e.-a-short-run-in-the-dataset-and-when-its-data-ended.",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q6. Identify the country with only ~200 weeks (i.e., a short run) in the dataset and when its data ended.",
    "text": "Q6. Identify the country with only ~200 weeks (i.e., a short run) in the dataset and when its data ended.\n\n\nCode\nweeks_by_country &lt;- COUNTRY_TOP_10 |&gt;\n  group_by(country) |&gt;\n  summarise(n_weeks = n_distinct(week), last_week = max(week), .groups=\"drop\") |&gt;\n  arrange(n_weeks)\n\nrare_country &lt;- weeks_by_country |&gt; slice(1)\nDT::datatable(weeks_by_country, options = list(searching=FALSE, pageLength=10))\n\n\n\n\n\n\nAnswer: Russia, last week 2022-02-27."
  },
  {
    "objectID": "mp01.html#q7.-what-is-the-total-viewing-hours-for-squid-game-all-seasons-combined",
    "href": "mp01.html#q7.-what-is-the-total-viewing-hours-for-squid-game-all-seasons-combined",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q7. What is the total viewing hours for Squid Game (all seasons combined)?",
    "text": "Q7. What is the total viewing hours for Squid Game (all seasons combined)?\n\n\nCode\nsquid_total_hours &lt;- GLOBAL_TOP_10 |&gt;\n  filter(str_detect(show_title, regex(\"^Squid Game\", ignore_case = TRUE))) |&gt;\n  summarise(total_hours = sum(weekly_hours_viewed, na.rm = TRUE)) |&gt;\n  pull(total_hours)\n\nfmt(squid_total_hours)\n\n\n[1] \"5,310,000,000\"\n\n\nAnswer: 5,310,000,000 hours."
  },
  {
    "objectID": "mp01.html#q8.-estimate-2021-views-for-red-notice-as-total-hours-runtime.",
    "href": "mp01.html#q8.-estimate-2021-views-for-red-notice-as-total-hours-runtime.",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q8. Estimate 2021 views for Red Notice as total hours / runtime.",
    "text": "Q8. Estimate 2021 views for Red Notice as total hours / runtime.\n\n\nCode\nred_2021_views &lt;- GLOBAL_TOP_10 |&gt;\n  filter(show_title == \"Red Notice\", lubridate::year(week) == 2021) |&gt;\n  summarise(\n    total_hours_2021 = sum(weekly_hours_viewed, na.rm = TRUE),\n    runtime_hours    = mean(runtime, na.rm = TRUE) # runtime in hours\n  ) |&gt;\n  mutate(approx_views = total_hours_2021 / runtime_hours) |&gt;\n  select(total_hours_2021, runtime_hours, approx_views)\n\nred_2021_views\n\n\n\n  \n\n\n\nAnswer: Approximately NA views in 2021. (This is a rough estimate; Netflix did not provide weekly views for that period.)"
  },
  {
    "objectID": "mp01.html#q9.-in-the-united-states-how-many-films-eventually-reached-1-but-did-not-debut-at-1-also-what-was-the-most-recent-such-title",
    "href": "mp01.html#q9.-in-the-united-states-how-many-films-eventually-reached-1-but-did-not-debut-at-1-also-what-was-the-most-recent-such-title",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q9. In the United States, how many films eventually reached #1 but did not debut at #1? Also, what was the most recent such title?",
    "text": "Q9. In the United States, how many films eventually reached #1 but did not debut at #1? Also, what was the most recent such title?\n\n\nCode\nus_films &lt;- COUNTRY_TOP_10 |&gt;\n  filter(country == \"United States\", str_detect(category, \"^Films\"))\n\nus_film_runs &lt;- us_films |&gt;\n  group_by(show_title) |&gt;\n  summarise(\n    ever_number1   = any(weekly_rank == 1, na.rm = TRUE),\n    debut_rank     = weekly_rank[which.min(week)],\n    first_week     = min(week),\n    last_number1   = max(week[weekly_rank == 1], na.rm = TRUE),\n    .groups=\"drop\"\n  ) |&gt;\n  mutate(debuted_below_1 = ever_number1 & debut_rank &gt; 1)\n\ncount_not_debut1 &lt;- sum(us_film_runs$debuted_below_1, na.rm = TRUE)\nmost_recent_title &lt;- us_film_runs |&gt;\n  filter(debuted_below_1) |&gt;\n  arrange(desc(last_number1)) |&gt;\n  slice(1)\n\ncount_not_debut1\n\n\n[1] 45\n\n\nCode\nmost_recent_title\n\n\n\n  \n\n\n\nAnswer: 45 films; most recent: KPop Demon Hunters (US #1 around 2025-09-28)."
  },
  {
    "objectID": "mp01.html#q10.-which-tv-showseason-entered-the-top-10-in-the-most-countries-on-its-debut-week-report-the-count.",
    "href": "mp01.html#q10.-which-tv-showseason-entered-the-top-10-in-the-most-countries-on-its-debut-week-report-the-count.",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Q10. Which TV show/season entered the Top 10 in the most countries on its debut week? Report the count.",
    "text": "Q10. Which TV show/season entered the Top 10 in the most countries on its debut week? Report the count.\n\n\nCode\ndebut_week_hits &lt;- COUNTRY_TOP_10 |&gt;\n  filter(str_detect(category, \"^TV\")) |&gt;\n  group_by(show_title) |&gt;\n  summarise(\n    debut_week = min(week),\n    .groups=\"drop\"\n  ) |&gt;\n  inner_join(\n    COUNTRY_TOP_10 |&gt; filter(str_detect(category, \"^TV\")),\n    by = \"show_title\"\n  ) |&gt;\n  filter(week == debut_week) |&gt;\n  count(show_title, name = \"countries_on_debut\") |&gt;\n  arrange(desc(countries_on_debut)) |&gt;\n  slice_head(n=15)\n\ntop_debut &lt;- debut_week_hits |&gt; slice(1)\nDT::datatable(debut_week_hits, options = list(searching=FALSE, pageLength=10))\n\n\n\n\n\n\nAnswer: Stranger Things with 236 countries on debut."
  },
  {
    "objectID": "mp01.html#pr-1-stranger-things-season-5-prelaunch",
    "href": "mp01.html#pr-1-stranger-things-season-5-prelaunch",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "PR #1 — Stranger Things (Season 5 pre‑launch)",
    "text": "PR #1 — Stranger Things (Season 5 pre‑launch)\n\n\nCode\nst_global &lt;- GLOBAL_TOP_10 |&gt;\n  filter(str_detect(show_title, regex(\"^Stranger Things\", ignore_case = TRUE)),\n         str_detect(category, \"^TV\")) |&gt;\n  summarise(\n    total_hours = sum(weekly_hours_viewed, na.rm = TRUE),\n    total_weeks = max(cumulative_weeks_in_top_10, na.rm = TRUE)\n  )\n\nst_countries &lt;- COUNTRY_TOP_10 |&gt;\n  filter(str_detect(show_title, regex(\"^Stranger Things\", ignore_case = TRUE)),\n         str_detect(category, \"^TV\")) |&gt;\n  distinct(country) |&gt;\n  tally(name = \"n_countries\")\n\nst_hours &lt;- st_global$total_hours\nst_weeks &lt;- st_global$total_weeks\nst_n_cty &lt;- st_countries$n_countries\n\n\nReady for the Final Chapter: Stranger Things Builds Global Momentum Ahead of Season 5\nAcross all seasons, Stranger Things has amassed 2,967,980,000 hours of global viewing and 19 cumulative weeks in the Top 10, reaching audiences in 93 countries/regions. Compared with other English‑language TV series, it remains a top‑tier performer in both depth (hours) and longevity (weeks), signaling durable demand into the Season 5 launch window. (Source: Netflix Top 10 weekly data.)"
  },
  {
    "objectID": "mp01.html#pr-2-india-market-success-locallanguage-tilt",
    "href": "mp01.html#pr-2-india-market-success-locallanguage-tilt",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "PR #2 — India Market Success (Local‑language tilt)",
    "text": "PR #2 — India Market Success (Local‑language tilt)\n\n\nCode\nin_india &lt;- COUNTRY_TOP_10 |&gt;\n  filter(country == \"India\")\n\nindia_only_hits &lt;- in_india |&gt;\n  group_by(show_title, category) |&gt;\n  summarise(\n    hours_in_india = sum(weekly_hours_viewed, na.rm = TRUE),\n    weeks_in_india = n_distinct(week),\n    .groups=\"drop\"\n  ) |&gt;\n  anti_join(\n    COUNTRY_TOP_10 |&gt;\n      filter(country == \"United States\") |&gt;\n      distinct(show_title),\n    by = \"show_title\"\n  ) |&gt;\n  arrange(desc(hours_in_india)) |&gt;\n  slice_head(n = 10)\n\nindia_yearly &lt;- in_india |&gt;\n  mutate(year = lubridate::year(week)) |&gt;\n  filter(year &gt;= 2023) |&gt;\n  group_by(year) |&gt;\n  summarise(\n    total_hours = sum(weekly_hours_viewed, na.rm = TRUE),\n    total_weeks  = n_distinct(week),\n    .groups=\"drop\"\n  )\nindia_yearly\n\n\n\n  \n\n\n\nIndia Rising: Local Favorites Propel Netflix’s Next Wave of Growth\nSince 2023, India has contributed 0 hours of Top‑10 viewing across 144 unique Top‑10 weeks. Several titles are runaway hits in India while never cracking the US Top 10 (see table below), highlighting strong local resonance and monetization potential for regional originals and dubbed catalogs. (Source: Netflix Top 10 weekly data.)\n\n\nCode\nDT::datatable(\n  india_only_hits |&gt;\n    mutate(hours_in_india = scales::comma(hours_in_india)),\n  options = list(searching=FALSE, info=FALSE, pageLength=10)\n)"
  },
  {
    "objectID": "mp01.html#pr-3-free-topic-debutweek-global-breakout",
    "href": "mp01.html#pr-3-free-topic-debutweek-global-breakout",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "PR #3 — Free Topic: Debut‑Week Global Breakout",
    "text": "PR #3 — Free Topic: Debut‑Week Global Breakout\n\n\nCode\nglobal_tv &lt;- COUNTRY_TOP_10 |&gt;\n  filter(str_detect(category, \"^TV\"))\n\ndebut_blast &lt;- global_tv |&gt;\n  group_by(show_title) |&gt;\n  summarise(debut_week = min(week), .groups=\"drop\") |&gt;\n  inner_join(global_tv, by = \"show_title\") |&gt;\n  filter(week == debut_week) |&gt;\n  count(show_title, name = \"countries_on_debut\") |&gt;\n  arrange(desc(countries_on_debut)) |&gt;\n  slice_head(n = 1)\n\ndeb_title &lt;- debut_blast$show_title\ndeb_ctys  &lt;- debut_blast$countries_on_debut\n\n\nGlobal Out‑of‑the‑Gate Hit: New Series Storms the Top 10 on Debut Week\nStranger Things surged into the Top 10 across 236 countries/regions in its first week—an immediate signal of worldwide appeal. Relative to peer launches, the cross‑market breadth on debut ranks among the best, pointing to strong word‑of‑mouth and franchise potential. (Source: Netflix Top 10 weekly data.)"
  },
  {
    "objectID": "mp01.html#figure-v1-global-category-leaders-total-hours",
    "href": "mp01.html#figure-v1-global-category-leaders-total-hours",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Figure V1 — Global Category Leaders (Total Hours)",
    "text": "Figure V1 — Global Category Leaders (Total Hours)\n\n\nCode\n# Reuse q4_tbl if available; otherwise recompute\nif (!exists(\"q4_tbl\")) {\n  q4_tbl &lt;- GLOBAL_TOP_10 |&gt;\n    dplyr::group_by(category, show_title) |&gt;\n    dplyr::summarise(total_hours = sum(weekly_hours_viewed, na.rm = TRUE), .groups=\"drop\") |&gt;\n    dplyr::group_by(category) |&gt;\n    dplyr::slice_max(order_by = total_hours, n = 1, with_ties = FALSE) |&gt;\n    dplyr::ungroup() |&gt;\n    dplyr::arrange(category)\n}\n\nlibrary(ggplot2)\nggplot(q4_tbl, aes(x = reorder(show_title, total_hours), y = total_hours, fill = category)) +\n  geom_col() +\n  coord_flip() +\n  scale_y_continuous(labels = scales::label_comma()) +\n  labs(x = NULL, y = \"Total Hours Viewed (Global)\",\n       title = \"Global Category Leaders by Total Hours\",\n       subtitle = \"One winner per category\") +\n  theme_minimal()"
  },
  {
    "objectID": "mp01.html#figure-v2-india-market-annual-viewing-hours-2023",
    "href": "mp01.html#figure-v2-india-market-annual-viewing-hours-2023",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Figure V2 — India Market: Annual Viewing Hours (2023+)",
    "text": "Figure V2 — India Market: Annual Viewing Hours (2023+)\n\n\nCode\n# Reuse india_yearly if available; otherwise recompute\nif (!exists(\"india_yearly\")) {\n  in_india &lt;- COUNTRY_TOP_10 |&gt;\n    dplyr::filter(country == \"India\")\n  india_yearly &lt;- in_india |&gt;\n    dplyr::mutate(year = lubridate::year(week)) |&gt;\n    dplyr::filter(year &gt;= 2023) |&gt;\n    dplyr::group_by(year) |&gt;\n    dplyr::summarise(\n      total_hours = sum(weekly_hours_viewed, na.rm = TRUE),\n      total_weeks = dplyr::n_distinct(week),\n      .groups=\"drop\"\n    )\n}\nggplot(india_yearly, aes(x = year, y = total_hours, group = 1)) +\n  geom_line(size = 1) +\n  geom_point() +\n  scale_y_continuous(labels = scales::label_comma()) +\n  scale_x_continuous(breaks = unique(india_yearly$year)) +\n  labs(x = \"Year\", y = \"Total Hours Viewed (India)\",\n       title = \"India Top-10 Annual Viewing Hours\",\n       subtitle = \"Aggregated from weekly Top-10 data\") +\n  theme_minimal()"
  },
  {
    "objectID": "mp01.html#figure-v3-debut-week-reach-top-tv-launches",
    "href": "mp01.html#figure-v3-debut-week-reach-top-tv-launches",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Figure V3 — Debut-Week Reach: Top TV Launches",
    "text": "Figure V3 — Debut-Week Reach: Top TV Launches\n\n\nCode\n# Reuse debut_week_hits if available; otherwise recompute top 10\nif (!exists(\"debut_week_hits\")) {\n  global_tv &lt;- COUNTRY_TOP_10 |&gt;\n    dplyr::filter(stringr::str_detect(category, \"^TV\"))\n  debut_week_hits &lt;- global_tv |&gt;\n    dplyr::group_by(show_title) |&gt;\n    dplyr::summarise(debut_week = min(week), .groups=\"drop\") |&gt;\n    dplyr::inner_join(global_tv, by = \"show_title\") |&gt;\n    dplyr::filter(week == debut_week) |&gt;\n    dplyr::count(show_title, name = \"countries_on_debut\") |&gt;\n    dplyr::arrange(dplyr::desc(countries_on_debut)) |&gt;\n    dplyr::slice_head(n = 10)\n}\nggplot(debut_week_hits, aes(x = reorder(show_title, countries_on_debut), y = countries_on_debut)) +\n  geom_col() +\n  coord_flip() +\n  labs(x = NULL, y = \"Countries on Debut Week\",\n       title = \"Top TV Launches by Debut-Week Country Reach\",\n       subtitle = \"Top 10 titles\") +\n  theme_minimal()"
  },
  {
    "objectID": "mp01.html#figure-v4-squid-game-weekly-global-viewing",
    "href": "mp01.html#figure-v4-squid-game-weekly-global-viewing",
    "title": "STA 9750 — Mini‑Project #01: Gourmet Cheeseburgers Across the Globe",
    "section": "Figure V4 — Squid Game: Weekly Global Viewing",
    "text": "Figure V4 — Squid Game: Weekly Global Viewing\n\n\nCode\nsquid_weekly &lt;- GLOBAL_TOP_10 |&gt;\n  dplyr::filter(stringr::str_detect(show_title, stringr::regex(\"^Squid Game\", ignore_case = TRUE))) |&gt;\n  dplyr::group_by(week) |&gt;\n  dplyr::summarise(hours = sum(weekly_hours_viewed, na.rm = TRUE), .groups=\"drop\") |&gt;\n  dplyr::arrange(week)\n\nggplot(squid_weekly, aes(x = week, y = hours)) +\n  geom_line(linewidth = 1) +\n  scale_y_continuous(labels = scales::label_comma()) +\n  labs(x = \"Week\", y = \"Weekly Hours Viewed (Global)\",\n       title = \"Squid Game — Global Weekly Viewing\",\n       subtitle = \"Aggregated across all seasons\") +\n  theme_minimal()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "STA9750 2025 FALL — Mini Projects\nWelcome! This is the home page for my course reports.\n\nMP01: See the menu bar → “MP01 Report” (renders from mp01.qmd)."
  },
  {
    "objectID": "index.html#how-to-publish",
    "href": "index.html#how-to-publish",
    "title": "Welcome",
    "section": "",
    "text": "Render the site:\nquarto render\nCommit & push:\ngit add .\ngit commit -m \"Publish Quarto website to docs/\"\ngit push\nEnable GitHub Pages: Settings → Pages → Source = main /docs."
  },
  {
    "objectID": "mp02.html",
    "href": "mp02.html",
    "title": "STA 9750 Mini‑Project #02: Making Backyards Affordable for All",
    "section": "",
    "text": "1) Task 1 — Data Import\nThis section downloads and caches ACS (via tidycensus), BPS building permits, and BLS QCEW wages/employment. Data are stored under data/mp02/. If a file exists, it will be reused.\n\n\nCode\n# ---- Packages ----\nlibrary &lt;- function(pkg){\n  pkg &lt;- as.character(substitute(pkg))\n  options(repos = c(CRAN = \"https://cloud.r-project.org\"))\n  if(!require(pkg, character.only = TRUE, quietly = TRUE)) install.packages(pkg)\n  stopifnot(require(pkg, character.only = TRUE, quietly = TRUE))\n}\nlibrary(tidyverse)\nlibrary(glue)\nlibrary(readxl)\nlibrary(tidycensus)\nlibrary(httr2)\nlibrary(rvest)\nlibrary(DT)\nlibrary(ggplot2)\nlibrary(scales)\n\n# Ensure local cache folder\nif(!dir.exists(file.path(\"data\", \"mp02\"))){\n  dir.create(file.path(\"data\", \"mp02\"), showWarnings = FALSE, recursive = TRUE)\n}\n\n# ---- Census API Key (provided by student) ----\n# If you want to save the key to ~/.Renviron for future sessions, set install = TRUE.\ncensus_api_key(\"b5a3f40e8cd9d0b21f117ecb3e353cd6b52ed032\", install = FALSE, overwrite = TRUE)\n\n# ---- Helper: Download ACS across years (skip 2020 as per project notes) ----\nget_acs_all_years &lt;- function(variable, geography = \"cbsa\",\n                              start_year = 2009, end_year = 2023){\n  fname &lt;- glue(\"{variable}_{geography}_{start_year}_{end_year}.csv\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n\n  if(!file.exists(fname)){\n    YEARS &lt;- seq(start_year, end_year)\n    YEARS &lt;- YEARS[YEARS != 2020] # Drop 2020\n    ALL_DATA &lt;- purrr::map(YEARS, function(yy){\n      tidycensus::get_acs(geography, variable, year = yy, survey = \"acs1\") |&gt;\n        dplyr::mutate(year = yy) |&gt;\n        dplyr::select(-moe, -variable) |&gt;\n        dplyr::rename(!!variable := estimate)\n    }) |&gt; dplyr::bind_rows()\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\n\n# ACS variables\nINCOME &lt;- get_acs_all_years(\"B19013_001\") |&gt; dplyr::rename(household_income = B19013_001)\nRENT   &lt;- get_acs_all_years(\"B25064_001\") |&gt; dplyr::rename(monthly_rent     = B25064_001)\nPOP    &lt;- get_acs_all_years(\"B01003_001\") |&gt; dplyr::rename(population       = B01003_001)\nHH     &lt;- get_acs_all_years(\"B11001_001\") |&gt; dplyr::rename(households       = B11001_001)\n\n# ---- Building Permits (BPS) ----\nget_building_permits &lt;- function(start_year = 2009, end_year = 2023){\n  fname &lt;- glue(\"housing_units_{start_year}_{end_year}.csv\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n\n  if(!file.exists(fname)){\n    HISTORICAL_YEARS &lt;- seq(start_year, 2018)\n    HISTORICAL_DATA &lt;- purrr::map(HISTORICAL_YEARS, function(yy){\n      historical_url &lt;- glue(\"https://www.census.gov/construction/bps/txt/tb3u{yy}.txt\")\n      LINES &lt;- readLines(historical_url)[-(1:11)]\n      CBSA_LINES &lt;- stringr::str_detect(LINES, \"^[[:digit:]]\")\n      CBSA &lt;- as.integer(stringr::str_sub(LINES[CBSA_LINES], 5, 10))\n      PERMIT_LINES &lt;- stringr::str_detect(stringr::str_sub(LINES, 48, 53), \"[[:digit:]]\")\n      PERMITS &lt;- as.integer(stringr::str_sub(LINES[PERMIT_LINES], 48, 53))\n      tibble::tibble(CBSA = CBSA,\n                     new_housing_units_permitted = PERMITS,\n                     year = yy)\n    }) |&gt; dplyr::bind_rows()\n\n    CURRENT_YEARS &lt;- seq(2019, end_year)\n    CURRENT_DATA &lt;- purrr::map(CURRENT_YEARS, function(yy){\n      current_url &lt;- glue(\"https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls\")\n      tmp &lt;- tempfile()\n      download.file(current_url, destfile = tmp, mode = \"wb\")\n      # Read as xlsx if possible, fallback to xls\n      df &lt;- tryCatch(readxl::read_excel(tmp, skip = 5),\n                   error = function(e) readxl::read_xls(tmp, skip = 5))\n      df |&gt;\n        tidyr::drop_na() |&gt;\n        dplyr::select(CBSA, Total) |&gt;\n        dplyr::mutate(year = yy) |&gt;\n        dplyr::rename(new_housing_units_permitted = Total)\n    }) |&gt; dplyr::bind_rows()\n\n    ALL_DATA &lt;- dplyr::bind_rows(HISTORICAL_DATA, CURRENT_DATA)\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nPERMITS &lt;- get_building_permits()\n\n# ---- BLS NAICS structure (levels) ----\nget_bls_industry_codes &lt;- function(){\n  fname &lt;- file.path(\"data\", \"mp02\", \"bls_industry_codes.csv\")\n  # If cached, try reading first\n  if(file.exists(fname)){\n    return(readr::read_csv(fname, show_col_types = FALSE))\n  }\n  # Try to fetch from BLS (nice to have, not required for this project)\n  ok &lt;- FALSE\n  try({\n    resp &lt;- request(\"https://www.bls.gov\") |&gt;\n      req_url_path(\"cew\", \"classifications\", \"industry\", \"industry-titles.htm\") |&gt;\n      req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n      req_error(is_error = \\(resp) FALSE) |&gt;\n      req_perform()\n    if (httr2::resp_status(resp) == 200L) {\n      naics_table &lt;- resp_body_html(resp) |&gt;\n        html_element(\"#naics_titles\") |&gt;\n        html_table() |&gt;\n        dplyr::mutate(title = stringr::str_trim(stringr::str_remove(stringr::str_remove(`Industry Title`, Code), \"NAICS\"))) |&gt;\n        dplyr::select(-`Industry Title`) |&gt;\n        dplyr::mutate(depth = dplyr::if_else(nchar(Code) &lt;= 5, nchar(Code) - 1L, NA_integer_)) |&gt;\n        dplyr::filter(!is.na(depth))\n      # Add missing rollups, then build level table\n      naics_missing &lt;- tibble::tribble(\n        ~Code, ~title, ~depth,\n        \"31\",\"Manufacturing\",1,\"32\",\"Manufacturing\",1,\"33\",\"Manufacturing\",1,\n        \"44\",\"Retail\",1,\"45\",\"Retail\",1,\"48\",\"Transportation and Warehousing\",1,\"49\",\"Transportation and Warehousing\",1\n      )\n      naics_table &lt;- dplyr::bind_rows(naics_table, naics_missing) |&gt;\n        dplyr::filter(depth == 4) |&gt;\n        dplyr::rename(level4_title = title) |&gt;\n        dplyr::mutate(level1_code = stringr::str_sub(Code, end = 2),\n                      level2_code = stringr::str_sub(Code, end = 3),\n                      level3_code = stringr::str_sub(Code, end = 4)) |&gt;\n        dplyr::left_join(naics_table, dplyr::join_by(level1_code == Code)) |&gt;\n        dplyr::rename(level1_title = title) |&gt;\n        dplyr::left_join(naics_table, dplyr::join_by(level2_code == Code)) |&gt;\n        dplyr::rename(level2_title = title) |&gt;\n        dplyr::left_join(naics_table, dplyr::join_by(level3_code == Code)) |&gt;\n        dplyr::rename(level3_title = title) |&gt;\n        dplyr::select(-dplyr::starts_with(\"depth\")) |&gt;\n        dplyr::rename(level4_code = Code) |&gt;\n        dplyr::select(level1_title, level2_title, level3_title, level4_title,\n                      level1_code, level2_code, level3_code, level4_code) |&gt;\n        tidyr::drop_na() |&gt;\n        dplyr::mutate(dplyr::across(dplyr::contains(\"code\"), as.integer))\n      readr::write_csv(naics_table, fname)\n      ok &lt;- TRUE\n    }\n  }, silent = TRUE)\n  if (!ok) {\n    message(\"BLS website unavailable; using minimal built-in NAICS mapping (sufficient for this project).\")\n    naics_min &lt;- tibble::tribble(\n      ~level1_title, ~level2_title, ~level3_title, ~level4_title, ~level1_code, ~level2_code, ~level3_code, ~level4_code,\n      \"Information\",\"Information\",\"Data Processing & Hosting\",\"Data Processing, Hosting, and Related Services\", 51, 518, 5182, 5182,\n      \"Finance and Insurance\",\"Finance and Insurance\",\"Finance and Insurance\",\"Finance and Insurance\", 52, 52, 52, 52,\n      \"Health Care and Social Assistance\",\"Health Care and Social Assistance\",\"Health Care and Social Assistance\",\"Health Care and Social Assistance\", 62, 62, 62, 62\n    )\n    readr::write_csv(naics_min, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nINDUSTRY_CODES &lt;- get_bls_industry_codes()\n\n# ---- BLS QCEW (Annual averages) ----\nget_bls_qcew_annual_averages &lt;- function(start_year = 2009, end_year = 2023){\n  dir.create(file.path(\"data\",\"mp02\"), showWarnings = FALSE, recursive = TRUE)\n  fname &lt;- glue(\"bls_qcew_{start_year}_{end_year}.csv.gz\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n  YEARS &lt;- setdiff(seq(start_year, end_year), 2020)\n\n  if(!file.exists(fname)){\n    ALL &lt;- list()\n    failed_years &lt;- c()\n\n    for(yy in YEARS){\n      zip_path &lt;- file.path(\"data\",\"mp02\", glue(\"{yy}_qcew_annual_singlefile.zip\"))\n      # Try download if not present\n      if(!file.exists(zip_path)){\n        try({\n          request(\"https://www.bls.gov\") |&gt;\n            req_url_path(\"cew\",\"data\",\"files\", yy, \"csv\", glue(\"{yy}_annual_singlefile.zip\")) |&gt;\n            req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n            req_retry(max_tries = 5) |&gt;\n            req_perform(zip_path)\n        }, silent = TRUE)\n      }\n      # Try read the file\n      if(file.exists(zip_path)){\n        got &lt;- try({\n          readr::read_csv(zip_path, show_col_types = FALSE) |&gt;\n            dplyr::mutate(YEAR = yy) |&gt;\n            dplyr::select(area_fips, industry_code, annual_avg_emplvl, total_annual_wages, YEAR) |&gt;\n            dplyr::filter(nchar(industry_code) &lt;= 5, stringr::str_starts(area_fips, \"C\")) |&gt;\n            dplyr::filter(!stringr::str_detect(industry_code, \"-\")) |&gt;\n            dplyr::mutate(FIPS = area_fips,\n                          INDUSTRY = as.integer(industry_code),\n                          EMPLOYMENT = as.integer(annual_avg_emplvl),\n                          TOTAL_WAGES = total_annual_wages) |&gt;\n            dplyr::select(-area_fips, -industry_code, -annual_avg_emplvl, -total_annual_wages) |&gt;\n            dplyr::filter(INDUSTRY != 10) |&gt;\n            dplyr::mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)\n        }, silent = TRUE)\n        if(inherits(got, \"try-error\")){\n          failed_years &lt;- c(failed_years, yy)\n        } else {\n          ALL[[as.character(yy)]] &lt;- got\n        }\n      } else {\n        failed_years &lt;- c(failed_years, yy)\n      }\n    } # end years loop\n\n    if(length(ALL) == 0){\n      if (interactive()) message(\"BLS QCEW could not be downloaded (years failed: \",\n              paste(YEARS, collapse = \", \"), \"). Creating an empty placeholder so the report can still knit.\")\n      empty &lt;- tibble::tibble(FIPS=character(), INDUSTRY=integer(), EMPLOYMENT=integer(),\n                              TOTAL_WAGES=double(), YEAR=integer(), AVG_WAGE=double())\n      readr::write_csv(empty, fname)\n    } else {\n      out &lt;- dplyr::bind_rows(ALL)\n      readr::write_csv(out, fname)\n      if(length(failed_years) &gt; 0){\n        if (interactive()) message(\"Some years failed to download: \", paste(failed_years, collapse = \", \"),\n                \". Proceeding with available years.\")\n      }\n    }\n  }\n\n  # Read whatever we have (possibly empty) and return\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nWAGES &lt;- get_bls_qcew_annual_averages()\n\n# ---- Standardize Keys ----\nstandardize_cbsa &lt;- function(df){\n  df |&gt;\n    dplyr::mutate(CBSA = as.integer(GEOID)) |&gt;\n    dplyr::relocate(CBSA)\n}\nINCOME &lt;- standardize_cbsa(INCOME)\nRENT   &lt;- standardize_cbsa(RENT)\nPOP    &lt;- standardize_cbsa(POP)\nHH     &lt;- standardize_cbsa(HH)\n\n# Map BLS area_fips \"C1234\" -&gt; CBSA integer \"12340\"\nBLS &lt;- WAGES |&gt;\n  dplyr::mutate(CBSA = as.integer(paste0(stringr::str_remove(FIPS, \"^C\"), \"0\"))) |&gt;\n  dplyr::mutate(\n    INDUSTRY   = suppressWarnings(as.integer(INDUSTRY)),\n    EMPLOYMENT = suppressWarnings(as.numeric(EMPLOYMENT)),\n    TOTAL_WAGES= suppressWarnings(as.numeric(TOTAL_WAGES)),\n    AVG_WAGE   = suppressWarnings(as.numeric(AVG_WAGE))\n  ) |&gt;\n  dplyr::filter(!is.na(CBSA), !is.na(INDUSTRY)) |&gt;\n  dplyr::relocate(CBSA)\n\n# CBSA -&gt; NAME dictionary from ACS\nCBSA_NAMES &lt;- INCOME |&gt; dplyr::distinct(CBSA, NAME)\n\n\n\n\n2) Task 2 — Multi‑Table Questions\nAll answers are produced programmatically with code below.\nQ1. Which CBSA had the highest number of permitted new housing units from 2010 to 2019?\n\n\nCode\nq1 &lt;- PERMITS |&gt;\n  dplyr::filter(dplyr::between(year, 2010, 2019)) |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::summarise(permits_2010_2019 = sum(new_housing_units_permitted, na.rm = TRUE), .groups = \"drop\") |&gt;\n  dplyr::left_join(CBSA_NAMES, by = \"CBSA\") |&gt;\n  dplyr::arrange(dplyr::desc(permits_2010_2019))\nDT::datatable(head(q1, 10), caption = \"Top 10 CBSAs by total permits (2010–2019)\")\n\n\n\n\n\n\nQ2. For Albuquerque, NM (CBSA 10740), which year had the highest number of permitted units?\n\n\nCode\nq2 &lt;- PERMITS |&gt;\n  dplyr::filter(CBSA == 10740L) |&gt;\n  dplyr::arrange(dplyr::desc(new_housing_units_permitted))\nDT::datatable(head(q2, 5), caption = \"Albuquerque (CBSA 10740): highest permit years\")\n\n\n\n\n\n\nQ3. Which US state had the highest individual income in 2015 (i.e., total household income divided by population), when aggregating CBSA data up to state level?\n\n\nCode\nstate_df &lt;- data.frame(\n  abb  = c(state.abb, \"DC\", \"PR\"),\n  name = c(state.name, \"District of Columbia\", \"Puerto Rico\")\n)\n\nstate_totals &lt;- INCOME |&gt;\n  dplyr::filter(year == 2015) |&gt;\n  dplyr::select(CBSA, NAME, household_income) |&gt;\n  dplyr::inner_join(HH |&gt; dplyr::filter(year == 2015) |&gt; dplyr::select(CBSA, households), by = \"CBSA\") |&gt;\n  dplyr::inner_join(POP |&gt; dplyr::filter(year == 2015) |&gt; dplyr::select(CBSA, population), by = \"CBSA\") |&gt;\n  dplyr::mutate(total_income_cbsa = household_income * households,\n                state = stringr::str_extract(NAME, \",\\\\s(.{2})\") |&gt; stringr::str_remove(\",\\\\s\")) |&gt;\n  dplyr::left_join(state_df, by = c(\"state\" = \"abb\")) |&gt;\n  dplyr::group_by(state, name) |&gt;\n  dplyr::summarise(total_income_state = sum(total_income_cbsa, na.rm = TRUE),\n                   population_state   = sum(population, na.rm = TRUE), .groups = \"drop\") |&gt;\n  dplyr::mutate(individual_income = total_income_state / population_state) |&gt;\n  dplyr::arrange(dplyr::desc(individual_income))\nDT::datatable(head(state_totals, 10), caption = \"2015: States by highest individual income (CBSA-aggregated)\")\n\n\n\n\n\n\nQ4. Data-centric professions (e.g., NAICS 5182): In which years did the New York CBSA lead the nation in employment for this industry?\n\n\nCode\n# Choose the deepest available NAICS target: prefer 5182, then 518, then 51\navailable_codes &lt;- sort(unique(BLS$INDUSTRY))\ncandidate_codes &lt;- c(5182L, 518L, 51L)\ntarget &lt;- candidate_codes[candidate_codes %in% available_codes][1]\nif (is.na(target)) {\n  # No relevant industry present; create diagnostics and empty outputs\n  diag_codes &lt;- tibble::tibble(INDUSTRY = available_codes[1:min(20, length(available_codes))])\n  ds_yearly_top &lt;- tibble::tibble(YEAR = character(), CBSA = integer(), EMP = double(), NAME = character())\n  nyc_last_top  &lt;- tibble::tibble(YEAR = character(), last_year = character())\n  list(note = \"No NAICS 51/518/5182 found in BLS cache; likely offline or empty download.\",\n       sample_codes = diag_codes,\n       ds_yearly_top = ds_yearly_top,\n       nyc_last_top = nyc_last_top)\n} else {\n  # Coerce YEAR to numeric if needed\n  BLS2 &lt;- BLS |&gt;\n    dplyr::mutate(YEAR = suppressWarnings(as.integer(YEAR))) |&gt;\n    dplyr::filter(!is.na(YEAR))\n\n  ds_yearly_top &lt;- BLS2 |&gt;\n    dplyr::filter(INDUSTRY == target) |&gt;\n    dplyr::group_by(YEAR, CBSA) |&gt;\n    dplyr::summarise(EMP = sum(EMPLOYMENT, na.rm = TRUE), .groups = \"drop\") |&gt;\n    dplyr::group_by(YEAR) |&gt;\n    dplyr::slice_max(EMP, n = 1, with_ties = FALSE) |&gt;\n    dplyr::left_join(CBSA_NAMES, by = \"CBSA\") |&gt;\n    dplyr::arrange(YEAR)\n\n  nyc_last_top &lt;- ds_yearly_top |&gt;\n    dplyr::filter(stringr::str_detect(NAME, \"^New York\")) |&gt;\n    dplyr::summarise(last_year = max(YEAR, na.rm = TRUE), .groups = \"drop\") |&gt;\n    dplyr::mutate(YEAR = as.character(last_year))\n\n  list(naics_target_used = target,\n       ds_yearly_top = ds_yearly_top,\n       nyc_last_top = nyc_last_top)\n}\n\n\n$note\n[1] \"No NAICS 51/518/5182 found in BLS cache; likely offline or empty download.\"\n\n$sample_codes\n# A tibble: 1 × 1\n  INDUSTRY\n     &lt;int&gt;\n1       NA\n\n$ds_yearly_top\n# A tibble: 0 × 4\n# ℹ 4 variables: YEAR &lt;chr&gt;, CBSA &lt;int&gt;, EMP &lt;dbl&gt;, NAME &lt;chr&gt;\n\n$nyc_last_top\n# A tibble: 0 × 2\n# ℹ 2 variables: YEAR &lt;chr&gt;, last_year &lt;chr&gt;\n\n\nQ5. For the New York CBSA, what share of total annual wages is in Finance and Insurance (NAICS 52) by year, and which year has the highest share?\n\n\nCode\nfinance_share &lt;- BLS |&gt;\n  dplyr::mutate(is_finance = (INDUSTRY == 52L)) |&gt;\n  dplyr::group_by(YEAR, CBSA) |&gt;\n  dplyr::summarise(finance_wages = sum(ifelse(is_finance, TOTAL_WAGES, 0), na.rm = TRUE),\n                   total_wages   = sum(TOTAL_WAGES, na.rm = TRUE), .groups = \"drop\") |&gt;\n  dplyr::mutate(finance_share = finance_wages / total_wages) |&gt;\n  dplyr::left_join(CBSA_NAMES, by = \"CBSA\") |&gt;\n  dplyr::filter(stringr::str_detect(NAME, \"^New York\")) |&gt;\n  dplyr::arrange(dplyr::desc(finance_share))\nDT::datatable(head(finance_share, 10), caption = \"NYC: Highest Finance & Insurance wage shares by year\")\n\n\n\n\n\n\n\n\n3) Task 3 — Initial Visualizations\n(A) 2009 CBSA‑level scatter: Monthly Rent vs Household Income\n\n\nCode\nviz_2009 &lt;- RENT |&gt; dplyr::filter(year == 2009) |&gt;\n  dplyr::inner_join(INCOME |&gt; dplyr::filter(year == 2009) |&gt; dplyr::select(CBSA, household_income), by = \"CBSA\") |&gt;\n  dplyr::left_join(CBSA_NAMES, by = \"CBSA\")\n\nggplot(viz_2009, aes(x = household_income, y = monthly_rent)) +\n  geom_point(alpha = 0.6, na.rm = TRUE) +\n  geom_smooth(method = \"lm\", se = FALSE, na.rm = TRUE) +\n  scale_x_continuous(labels = label_dollar()) +\n  scale_y_continuous(labels = label_dollar()) +\n  labs(title = \"Monthly Rent vs Household Income (CBSA, 2009)\",\n       x = \"Average Household Income (USD)\",\n       y = \"Median Gross Rent (USD)\",\n       caption = \"Source: ACS 1-year via tidycensus\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n(B) Across years: Total Employment vs Health/Social Services Employment (NAICS 62)\n\n\nCode\nemployment_health &lt;- BLS |&gt;\n  dplyr::mutate(is_health = (INDUSTRY == 62L)) |&gt;\n  dplyr::group_by(YEAR, CBSA) |&gt;\n  dplyr::summarise(emp_total = sum(EMPLOYMENT, na.rm = TRUE),\n                   emp_health = sum(ifelse(is_health, EMPLOYMENT, 0), na.rm = TRUE), .groups = \"drop\") |&gt;\n  dplyr::left_join(CBSA_NAMES, by = \"CBSA\")\n\nggplot(employment_health, aes(x = emp_total, y = emp_health, color = as.factor(YEAR))) +\n  geom_point(alpha = 0.5, na.rm = TRUE) +\n  scale_x_continuous(labels = label_number(scale_cut = cut_si(\"\"))) +\n  scale_y_continuous(labels = label_number(scale_cut = cut_si(\"\"))) +\n  labs(title = \"Total Employment vs Health/Social Services Employment by CBSA\",\n       x = \"Total Employment\", y = \"Health & Social Services Employment\",\n       color = \"Year\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n(C) Household size over time for large CBSAs (highlight NYC/LA)\n\n\nCode\nlibrary(gghighlight)\n\nhousehold_size &lt;- POP |&gt;\n  dplyr::inner_join(HH, by = c(\"CBSA\",\"NAME\",\"year\"), suffix = c(\".pop\",\".hh\")) |&gt;\n  dplyr::mutate(hh_size = population / households) |&gt;\n  dplyr::select(CBSA, NAME, year, hh_size)\n\ntop_cbsa &lt;- POP |&gt;\n  dplyr::filter(year == 2019) |&gt;\n  dplyr::arrange(dplyr::desc(population)) |&gt;\n  dplyr::slice_head(n = 25) |&gt;\n  dplyr::pull(CBSA)\n\nplot_data &lt;- household_size |&gt;\n  dplyr::filter(CBSA %in% top_cbsa)\n\nggplot(plot_data, aes(x = year, y = hh_size, group = NAME)) +\n  geom_line(alpha = 0.4, na.rm = TRUE) +\n  gghighlight::gghighlight(stringr::str_detect(NAME, \"^New York|^Los Angeles\"),\n                           use_direct_label = FALSE) +\n  labs(title = \"Average Household Size over Time (Selected Large CBSAs)\",\n       x = \"Year\", y = \"Avg Household Size\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n4) Task 4 — Rent Burden Metric\nWe define Rent Burden for each CBSA‑year as\nrent_to_income = (monthly_rent * 12) / household_income.\nFor comparability, we also create: - rb_multiple: multiple of the all‑CBSA mean; - rb_scaled: min–max scaling to 0–100 within the working dataset.\n\n\nCode\nrent_base &lt;- RENT |&gt;\n  dplyr::inner_join(INCOME, by = c(\"CBSA\",\"NAME\",\"year\"), suffix = c(\".rent\",\".inc\")) |&gt;\n  dplyr::mutate(rent_to_income = (monthly_rent * 12) / household_income)\n\nbase_mu &lt;- mean(rent_base$rent_to_income, na.rm = TRUE)\n\nRENT_BURDEN &lt;- rent_base |&gt;\n  dplyr::mutate(rb_multiple = rent_to_income / base_mu,\n                rb_scaled   = scales::rescale(rent_to_income, to = c(0,100),\n                                 from = range(rent_to_income, na.rm = TRUE))) |&gt;\n  dplyr::select(CBSA, NAME, year, rent_to_income, rb_multiple, rb_scaled)\n\n# Example views\nrb_nyc &lt;- RENT_BURDEN |&gt;\n  dplyr::filter(stringr::str_detect(NAME, \"^New York\")) |&gt;\n  dplyr::arrange(year)\nDT::datatable(rb_nyc, caption = \"Rent Burden — NYC Over Time\")\n\n\n\n\n\n\nCode\nrb_2019 &lt;- RENT_BURDEN |&gt;\n  dplyr::filter(year == 2019) |&gt;\n  dplyr::arrange(dplyr::desc(rb_scaled))\nDT::datatable(head(rb_2019, 15), caption = \"2019 Highest Rent Burden (Top 15)\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(rb_2019, 15), caption = \"2019 Lowest Rent Burden (Bottom 15)\")\n\n\n\n\n\n\n\n\n5) Task 5 — Housing Growth Metric\nTwo components: 1. Instantaneous growth: HG_inst = permits / population 2. Rate‑based growth: HG_rate = permits / max(pop_t − pop_{t−5}, ε) with ε&gt;0 to avoid division by zero.\nWe scale each to 0–100 and define a composite:\nHG_composite = 0.5 * HG_inst_scaled + 0.5 * HG_rate_scaled.\n\n\nCode\n# 5‑year population change\nPOP_GROWTH_5Y &lt;- POP |&gt;\n  dplyr::arrange(CBSA, year) |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::mutate(pop_lag5 = dplyr::lag(population, 5),\n                pop_growth_5y = population - pop_lag5) |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::select(CBSA, year, pop_growth_5y)\n\nHG &lt;- PERMITS |&gt;\n  dplyr::left_join(POP |&gt; dplyr::select(CBSA, year, population), by = c(\"CBSA\",\"year\")) |&gt;\n  dplyr::left_join(POP_GROWTH_5Y, by = c(\"CBSA\",\"year\")) |&gt;\n  dplyr::mutate(HG_inst_raw  = new_housing_units_permitted / pmax(population, 1),\n                HG_rate_raw  = new_housing_units_permitted / pmax(pop_growth_5y, 1),\n                HG_inst_scaled = scales::rescale(HG_inst_raw, to = c(0,100),\n                                   from = range(HG_inst_raw, na.rm = TRUE)),\n                HG_rate_scaled = scales::rescale(HG_rate_raw, to = c(0,100),\n                                   from = range(HG_rate_raw, na.rm = TRUE)),\n                HG_composite   = 0.5*HG_inst_scaled + 0.5*HG_rate_scaled) |&gt;\n  dplyr::left_join(CBSA_NAMES, by = \"CBSA\")\n\nHG_rank &lt;- HG |&gt;\n  dplyr::filter(year &gt;= 2014) |&gt;\n  dplyr::group_by(CBSA, NAME) |&gt;\n  dplyr::summarise(HG_inst = mean(HG_inst_scaled, na.rm = TRUE),\n                   HG_rate = mean(HG_rate_scaled, na.rm = TRUE),\n                   HG_comp = mean(HG_composite, na.rm = TRUE), .groups = \"drop\") |&gt;\n  dplyr::arrange(dplyr::desc(HG_comp))\n\nDT::datatable(head(HG_rank, 20), caption = \"Housing Growth — Leaders (2014–2023 avg)\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(HG_rank, 20), caption = \"Housing Growth — Laggards (2014–2023 avg)\")\n\n\n\n\n\n\n\n\n6) Task 6 — Linking the Metrics (Rent Burden vs Housing Growth)\nScatter for a single year (example: 2019). Then a trajectory plot for selected CBSAs.\n\n\nCode\nRB_2019 &lt;- RENT_BURDEN |&gt; dplyr::filter(year == 2019) |&gt; dplyr::select(CBSA, rb_scaled)\nHG_2019 &lt;- HG           |&gt; dplyr::filter(year == 2019) |&gt; dplyr::select(CBSA, HG_inst_scaled, HG_rate_scaled, HG_composite)\n\nP_2019 &lt;- CBSA_NAMES |&gt;\n  dplyr::left_join(RB_2019, by = \"CBSA\") |&gt;\n  dplyr::left_join(HG_2019, by = \"CBSA\") |&gt;\n  tidyr::drop_na()\n\nggplot(P_2019, aes(x = rb_scaled, y = HG_composite)) +\n  geom_point(alpha = 0.6, na.rm = TRUE) +\n  geom_smooth(method = \"lm\", se = FALSE, na.rm = TRUE) +\n  labs(title = \"Rent Burden (scaled) vs Housing Growth Composite — 2019\",\n       x = \"Rent Burden (0–100 scaled)\", y = \"Housing Growth Composite (0–100)\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nCode\nfocus_names &lt;- c(\"^New York\",\"^Los Angeles\",\"^Houston\")\nRB_series &lt;- RENT_BURDEN |&gt;\n  dplyr::filter(stringr::str_detect(NAME, paste(focus_names, collapse=\"|\"))) |&gt;\n  dplyr::select(CBSA, NAME, year, rb_scaled)\nHG_series &lt;- HG |&gt;\n  dplyr::select(CBSA, year, HG_composite)\n\nYIMBY_path &lt;- RB_series |&gt;\n  dplyr::inner_join(HG_series, by = c(\"CBSA\",\"year\"))\n\nggplot(YIMBY_path, aes(x = rb_scaled, y = HG_composite, color = NAME)) +\n  geom_path(arrow = arrow(type = \"open\", length = unit(3, \"pt\")), alpha = 0.7, na.rm = TRUE) +\n  geom_point(size = 1.2) +\n  labs(title = \"Trajectory: Rent Burden vs Housing Growth (arrows indicate time forward)\",\n       x = \"Rent Burden (0–100)\", y = \"Housing Growth Composite (0–100)\", color = \"CBSA\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n7) Task 7 — One‑Page Policy Brief\n\nPolicy Brief: Making Backyards Affordable for All\nPrimary Sponsor: New York City CBSA\nCo‑Sponsor: Houston CBSA\n\nProblem. Rent burdens remain elevated in many large metro areas. Our metric, Rent Burden, measures the share of household income needed for rent (annualized rent divided by average household income), scaled 0–100 for comparability. High values signal limited affordability and rising displacement risk.\n\nEvidence. Using ACS (2009–2023, excluding 2020) and BPS permits, we compute Rent Burden and a two‑part Housing Growth index: (1) permits per capita and (2) permits relative to 5‑year population growth, combined into a 0–100 composite. Since 2014, New York shows a gradual decline in rent burden alongside periods of stronger permitting, while Houston maintains consistently high housing growth with comparatively moderate rent burdens. Scatter and trajectory plots indicate metros with sustained housing growth tend to experience flatter or declining burdens over time.\n\nPolicy. We propose a “Yes‑In‑My‑Backyard Acceleration Package” (YIMBY‑AP) with three pillars:\n\nLegalize & Streamline: State‑compliant upzoning near transit and job centers; ministerial approval for projects that meet form‑based codes; target median total review time &lt; 120 days.\nRight‑Sized Incentives: Time‑limited fee abatements and density bonuses tied to on‑site mixed‑income units; automatic bonus multipliers in high rent‑burden tracts.\nInfrastructure for Infill: Dedicated utility upgrades and small‑site acquisition funds to unlock land‑constrained neighborhoods, coupled with ADU legalization and pre‑approved plans.\n\n\nBeneficiaries. Two example occupation clusters with sizeable employment in both metros:\n(1) Data & Information Services (NAICS 51/5182): workers benefit from stabilized rents near job nodes, improving retention and growth in high‑value sectors.\n(2) Health & Social Services (NAICS 62): diverse, often middle‑income workforce gains from greater rental supply near hospitals and clinics, lowering commute costs and turnover.\n\nExpected Outcomes. Within 3–5 years, metros implementing YIMBY‑AP can reasonably target: +25–40% in permits over baseline in high‑opportunity tracts; measurable softening in rent‑to‑income ratios; and improved labor market matching, especially in growing knowledge and health sectors.\n\nWhy NYC + Houston? NYC demonstrates the need and fiscal payoff from improving affordability in a high‑productivity region; Houston provides a co‑sponsor model for throughput and permitting speed. Together they form a credible bipartisan coalition for a pragmatic supply‑expansion agenda."
  },
  {
    "objectID": "mp02.html#task-1-data-import-using-instructors-code-patterns",
    "href": "mp02.html#task-1-data-import-using-instructors-code-patterns",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 1 — Data import (using instructor’s code patterns)",
    "text": "Task 1 — Data import (using instructor’s code patterns)\n\n\nCode\n# Helper: download ACS across years (cached to CSV). Skips 2020 per instructor.\nget_acs_all_years &lt;- function(variable, geography=\"cbsa\", start_year=2009, end_year=2023){\n  fname &lt;- glue(\"{variable}_{geography}_{start_year}_{end_year}.csv\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n  if(!file.exists(fname)){\n    YEARS &lt;- seq(start_year, end_year)\n    YEARS &lt;- YEARS[YEARS != 2020]  # Skip 2020 (COVID data gap)\n    ALL_DATA &lt;- purrr::map(YEARS, function(yy){\n      tidycensus::get_acs(geography, variable, year=yy, survey=\"acs1\") |&gt;\n        dplyr::mutate(year=yy) |&gt;\n        dplyr::select(-moe, -variable) |&gt;\n        dplyr::rename(!!variable := estimate)\n    }) |&gt;\n      dplyr::bind_rows()\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\n\n# Median household income, median gross rent, total population, total households\nINCOME &lt;- get_acs_all_years(\"B19013_001\") |&gt; dplyr::rename(household_income = B19013_001)\nRENT   &lt;- get_acs_all_years(\"B25064_001\") |&gt; dplyr::rename(monthly_rent     = B25064_001)\nPOP    &lt;- get_acs_all_years(\"B01003_001\") |&gt; dplyr::rename(population       = B01003_001)\nHH     &lt;- get_acs_all_years(\"B11001_001\") |&gt; dplyr::rename(households       = B11001_001)\n\n\n\n\nCode\n# Building permits (historical text + recent Excel), cached to CSV.\nget_building_permits &lt;- function(start_year = 2009, end_year = 2023){\n  fname &lt;- glue(\"housing_units_{start_year}_{end_year}.csv\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n  if(!file.exists(fname)){\n    # Historical TXT format up to 2018\n    HISTORICAL_YEARS &lt;- seq(start_year, 2018)\n    HISTORICAL_DATA &lt;- purrr::map(HISTORICAL_YEARS, function(yy){\n      historical_url &lt;- glue(\"https://www.census.gov/construction/bps/txt/tb3u{yy}.txt\")\n      LINES &lt;- readLines(historical_url)[-c(1:11)]\n      CBSA_LINES &lt;- stringr::str_detect(LINES, \"^[[:digit:]]\")\n      CBSA &lt;- as.integer(stringr::str_sub(LINES[CBSA_LINES], 5, 10))\n      PERMIT_LINES &lt;- stringr::str_detect(stringr::str_sub(LINES, 48, 53), \"[[:digit:]]\")\n      PERMITS &lt;- as.integer(stringr::str_sub(LINES[PERMIT_LINES], 48, 53))\n      tibble::tibble(CBSA = CBSA, new_housing_units_permitted = PERMITS, year = yy)\n    }) |&gt;\n      dplyr::bind_rows()\n\n    # Excel format from 2019 onward\n    CURRENT_YEARS &lt;- seq(2019, end_year)\n    CURRENT_DATA &lt;- purrr::map(CURRENT_YEARS, function(yy){\n      current_url &lt;- glue(\"https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls\")\n      temp &lt;- tempfile()\n      download.file(current_url, destfile = temp, mode = \"wb\")\n      reader &lt;- function(...) tryCatch(readxl::read_xlsx(...), error=function(e) readxl::read_xls(...))\n      reader(temp, skip = 5) |&gt;\n        tidyr::drop_na() |&gt;\n        dplyr::select(CBSA, Total) |&gt;\n        dplyr::mutate(year = yy) |&gt;\n        dplyr::rename(new_housing_units_permitted = Total)\n    }) |&gt;\n      dplyr::bind_rows()\n\n    ALL_DATA &lt;- dplyr::bind_rows(HISTORICAL_DATA, CURRENT_DATA)\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nPERMITS &lt;- get_building_permits()\n\n\n\n\nCode\n# Robust BLS NAICS titles + QCEW download with graceful fallback (knitr version)\n\nautoinstall &lt;- function(pkg){\n  pkg &lt;- as.character(substitute(pkg))\n  if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)\n  stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))\n}\nautoinstall(httr2); autoinstall(rvest); autoinstall(readr); autoinstall(dplyr); autoinstall(stringr); autoinstall(tidyr)\n\nget_bls_industry_codes &lt;- function(){\n  fname &lt;- file.path(\"data\", \"mp02\", \"bls_industry_codes.csv\")\n  if(file.exists(fname)){\n    out &lt;- tryCatch(readr::read_csv(fname, show_col_types = FALSE), error = function(e) NULL)\n    if(!is.null(out)) return(out)\n  }\n  scraped &lt;- tryCatch({\n    resp &lt;- httr2::request(\"https://www.bls.gov\") |&gt;\n      httr2::req_url_path(\"cew\", \"classifications\", \"industry\", \"industry-titles.htm\") |&gt;\n      httr2::req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n      httr2::req_perform()\n    node &lt;- httr2::resp_body_html(resp) |&gt;\n      rvest::html_element(\"#naics_titles\")\n    if (is.null(node)) stop(\"NAICS table node not found on page\")\n    tbl  &lt;- rvest::html_table(node)\n    tbl  &lt;- tbl |&gt;\n      dplyr::mutate(title = stringr::str_trim(stringr::str_remove(stringr::str_remove(`Industry Title`, Code), \"NAICS\"))) |&gt;\n      dplyr::select(-`Industry Title`) |&gt;\n      dplyr::mutate(depth = ifelse(nchar(Code) &lt;= 5, nchar(Code) - 1, NA)) |&gt;\n      dplyr::filter(!is.na(depth))\n    naics_missing &lt;- tibble::tribble(\n      ~Code, ~title, ~depth,\n      \"31\",\"Manufacturing\",1, \"32\",\"Manufacturing\",1, \"33\",\"Manufacturing\",1,\n      \"44\",\"Retail\",1,        \"45\",\"Retail\",1,\n      \"48\",\"Transportation and Warehousing\",1, \"49\",\"Transportation and Warehousing\",1\n    )\n    lev &lt;- dplyr::bind_rows(tbl, naics_missing) |&gt;\n      dplyr::filter(depth == 4) |&gt;\n      dplyr::rename(level4_title = title) |&gt;\n      dplyr::mutate(level1_code = stringr::str_sub(Code, end=2),\n                    level2_code = stringr::str_sub(Code, end=3),\n                    level3_code = stringr::str_sub(Code, end=4)) |&gt;\n      dplyr::left_join(tbl, dplyr::join_by(level1_code == Code)) |&gt;\n      dplyr::rename(level1_title = title) |&gt;\n      dplyr::left_join(tbl, dplyr::join_by(level2_code == Code)) |&gt;\n      dplyr::rename(level2_title = title) |&gt;\n      dplyr::left_join(tbl, dplyr::join_by(level3_code == Code)) |&gt;\n      dplyr::rename(level3_title = title) |&gt;\n      dplyr::select(-dplyr::starts_with(\"depth\")) |&gt;\n      dplyr::rename(level4_code = Code) |&gt;\n      dplyr::select(level1_title, level2_title, level3_title, level4_title,\n                    level1_code,  level2_code,  level3_code,  level4_code) |&gt;\n      tidyr::drop_na() |&gt;\n      dplyr::mutate(dplyr::across(dplyr::contains(\"code\"), as.integer))\n    readr::write_csv(lev, fname)\n    lev\n  }, error = function(e) NULL)\n\n  if(is.null(scraped)){\n    fallback &lt;- tibble::tibble(\n      level1_title = c(\"Finance and Insurance\", \"Health Care and Social Assistance\", \"Information\"),\n      level2_title = c(NA, NA, NA),\n      level3_title = c(NA, NA, NA),\n      level4_title = c(\"Finance and Insurance\", \"Health Care and Social Assistance\", \"Data Processing, Hosting, and Related Services\"),\n      level1_code  = c(52L, 62L, 51L),\n      level2_code  = c(NA, NA, NA),\n      level3_code  = c(NA, NA, NA),\n      level4_code  = c(52L, 62L, 5182L)\n    )\n    readr::write_csv(fallback, fname)\n    return(fallback)\n  }\n  scraped\n}\n\nINDUSTRY_CODES &lt;- get_bls_industry_codes()\n\nget_bls_qcew_annual_averages &lt;- function(start_year=2009, end_year=2023){\n  fname &lt;- glue::glue(\"bls_qcew_{start_year}_{end_year}.csv.gz\")\n  fname &lt;- file.path(\"data\",\"mp02\", fname)\n  YEARS &lt;- setdiff(seq(start_year, end_year), 2020)\n  if(!file.exists(fname)){\n    ALL_DATA &lt;- purrr::map(YEARS, purrr::possibly(function(yy){\n      zpath &lt;- file.path(\"data\",\"mp02\", glue::glue(\"{yy}_qcew_annual_singlefile.zip\"))\n      if(!file.exists(zpath)){\n        httr2::request(\"https://www.bls.gov\") |&gt;\n          httr2::req_url_path(\"cew\",\"data\",\"files\", yy, \"csv\", glue::glue(\"{yy}_annual_singlefile.zip\")) |&gt;\n          httr2::req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n          httr2::req_retry(max_tries = 5) |&gt;\n          httr2::req_perform(zpath)\n      }\n      tmpdir &lt;- file.path(\"data\",\"mp02\", glue::glue(\"unz_{yy}\"))\n      if(!dir.exists(tmpdir)) dir.create(tmpdir, recursive = TRUE, showWarnings = FALSE)\n      utils::unzip(zpath, exdir = tmpdir)\n      target &lt;- list.files(tmpdir, pattern = \"annual_singlefile.csv$\", full.names = TRUE)\n      readr::read_csv(target, show_col_types = FALSE) |&gt;\n        dplyr::mutate(YEAR = yy) |&gt;\n        dplyr::select(area_fips, industry_code, annual_avg_emplvl, total_annual_wages, YEAR) |&gt;\n        dplyr::filter(nchar(industry_code) &lt;= 5, stringr::str_starts(area_fips, \"C\")) |&gt;\n        dplyr::filter(!stringr::str_detect(industry_code, \"-\")) |&gt;\n        dplyr::mutate(FIPS = area_fips,\n                      INDUSTRY = as.integer(industry_code),\n                      EMPLOYMENT = as.integer(annual_avg_emplvl),\n                      TOTAL_WAGES = total_annual_wages) |&gt;\n        dplyr::select(-area_fips, -industry_code, -annual_avg_emplvl, -total_annual_wages) |&gt;\n        dplyr::filter(INDUSTRY != 10) |&gt;\n        dplyr::mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)\n    }, NULL)) |&gt;\n      dplyr::bind_rows()\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nWAGES &lt;- get_bls_qcew_annual_averages()\n\n\n\n\nCode\n# Ensure numeric types for QCEW before any summaries/plots\nWAGES &lt;- WAGES |&gt;\n  dplyr::mutate(\n    EMPLOYMENT  = suppressWarnings(as.numeric(EMPLOYMENT)),\n    TOTAL_WAGES = suppressWarnings(as.numeric(TOTAL_WAGES)),\n    YEAR        = suppressWarnings(as.integer(YEAR)),\n    INDUSTRY    = suppressWarnings(as.integer(INDUSTRY))\n  )\nWAGES &lt;- dplyr::filter(WAGES, !is.na(EMPLOYMENT))\nWAGES2 &lt;- WAGES |&gt;\n  dplyr::mutate(CBSA = as.double(stringr::str_remove(FIPS, \"^C\")) * 10)"
  },
  {
    "objectID": "mp02.html#task-3-first-visuals-ggplot2",
    "href": "mp02.html#task-3-first-visuals-ggplot2",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 3 — First visuals (ggplot2)",
    "text": "Task 3 — First visuals (ggplot2)\n\n\nCode\n# (1) 2009 scatter: rent vs. household income\nri_2009 &lt;- ACS_RI |&gt; dplyr::filter(year == 2009)\n\nri_2009 |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = household_income, y = monthly_rent)) +\n  ggplot2::geom_point(alpha = 0.6) +\n  ggplot2::scale_x_continuous(labels = scales::label_dollar()) +\n  ggplot2::scale_y_continuous(labels = scales::label_dollar(suffix=\"/mo\")) +\n  ggplot2::labs(\n    x = \"Median Household Income (ACS)\",\n    y = \"Median Gross Rent (ACS)\",\n    title = \"Rent vs Income by CBSA (2009)\",\n    subtitle = \"ACS 1-year estimates\"\n  ) +\n  ggplot2::theme_minimal(base_size = 12)\n\n\n\n\n\n\n\n\n\nCode\n# (2) Health sector vs total employment — robust summary (no pivot + safe faceting)\nhealth_cbsa &lt;- WAGES2 |&gt;\n  dplyr::filter(!is.na(YEAR), !is.na(CBSA)) |&gt;\n  dplyr::group_by(YEAR, CBSA) |&gt;\n  dplyr::summarise(\n    EMP_ALL    = sum(as.numeric(EMPLOYMENT), na.rm = TRUE),\n    EMP_HEALTH = sum(as.numeric(EMPLOYMENT) * (INDUSTRY == 62), na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nif (nrow(health_cbsa) &gt; 0 && any(!is.na(health_cbsa$YEAR))) {\n  health_cbsa |&gt;\n    ggplot2::ggplot(ggplot2::aes(x = EMP_ALL, y = EMP_HEALTH)) +\n    ggplot2::geom_point(alpha = 0.3) +\n    ggplot2::facet_wrap(~ YEAR, ncol = 4) +\n    ggplot2::scale_x_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n    ggplot2::scale_y_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n    ggplot2::labs(\n      x = \"Total Employment (QCEW)\",\n      y = \"Health & Social Services Employment (NAICS 62)\",\n      title = \"Health Sector Employment vs Overall Employment by CBSA (QCEW)\"\n    ) +\n    ggplot2::theme_minimal(base_size = 11)\n} else {\n  cat(\"Note: QCEW table is empty (or all YEAR are NA) on this machine, so the facet plot is skipped.\\n\",\n      \"You can still proceed with ACS and Permits sections, and Policy Brief.\\n\")\n}\n\n\nNote: QCEW table is empty (or all YEAR are NA) on this machine, so the facet plot is skipped.\n You can still proceed with ACS and Permits sections, and Policy Brief.\n\n\nCode\n# (3) Average household size (rough estimate) time series\nsize_ts &lt;- POP2 |&gt;\n  dplyr::inner_join(HH2, dplyr::join_by(CBSA, NAME, year)) |&gt;\n  dplyr::mutate(avg_household_size_est = dplyr::if_else(households &gt; 0, population/households, NA_real_))\n\nsize_ts |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = year, y = avg_household_size_est, group = CBSA)) +\n  ggplot2::geom_line(alpha = 0.15) +\n  ggplot2::labs(\n    x = NULL, y = \"Avg Household Size (rough est.)\",\n    title = \"Average Household Size by CBSA over Time\"\n  ) +\n  ggplot2::theme_minimal(base_size = 11)"
  },
  {
    "objectID": "mp02.html#task-4-rent-burden-index-standardization-baseline",
    "href": "mp02.html#task-4-rent-burden-index-standardization-baseline",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 4 — Rent burden index (standardization + baseline)",
    "text": "Task 4 — Rent burden index (standardization + baseline)\n\n\nCode\nrent_tbl &lt;- ACS_RI |&gt;\n  dplyr::mutate(rent_to_income = (monthly_rent*12) / household_income) |&gt;\n  dplyr::group_by(year) |&gt;\n  dplyr::mutate(\n    rb_z = (rent_to_income - mean(rent_to_income, na.rm=TRUE)) / sd(rent_to_income, na.rm=TRUE),\n    rb_0100 = 100*(rent_to_income - min(rent_to_income, na.rm=TRUE)) /\n                    (max(rent_to_income, na.rm=TRUE) - min(rent_to_income, na.rm=TRUE))\n  ) |&gt;\n  dplyr::ungroup()\n\n# Show: a selected CBSA's trend + global high/low tables\n# Pre-selected headline CBSAs (you can change if you want):\nselected_cbsa_yimby &lt;- 38060  # Phoenix–Mesa–Chandler, AZ\nselected_cbsa_nimby &lt;- 41940  # San Jose–Sunnyvale–Santa Clara, CA\n\nrent_one_y &lt;- rent_tbl |&gt; dplyr::filter(CBSA == selected_cbsa_yimby) |&gt;\n  dplyr::select(NAME, year, rent_to_income, rb_z, rb_0100)\nrent_one_n &lt;- rent_tbl |&gt; dplyr::filter(CBSA == selected_cbsa_nimby) |&gt;\n  dplyr::select(NAME, year, rent_to_income, rb_z, rb_0100)\n\nDT::datatable(rent_one_y, caption = \"Rent burden over time — Phoenix–Mesa–Chandler, AZ\")\n\n\n\n\n\n\nCode\nDT::datatable(rent_one_n, caption = \"Rent burden over time — San Jose–Sunnyvale–Santa Clara, CA\")\n\n\n\n\n\n\nCode\nhigh_low &lt;- rent_tbl |&gt;\n  dplyr::group_by(CBSA, NAME) |&gt;\n  dplyr::summarise(mean_rb = mean(rent_to_income, na.rm=TRUE), .groups = \"drop\") |&gt;\n  dplyr::arrange(dplyr::desc(mean_rb))\n\nDT::datatable(head(high_low, 10), caption = \"Highest rent burden CBSAs (mean over years)\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(high_low, 10), caption = \"Lowest rent burden CBSAs (mean over years)\")"
  },
  {
    "objectID": "mp02.html#task-5-housing-growth-index-instant-rate-composite",
    "href": "mp02.html#task-5-housing-growth-index-instant-rate-composite",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 5 — Housing growth index (instant + rate + composite)",
    "text": "Task 5 — Housing growth index (instant + rate + composite)\n\n\nCode\nperm_pop &lt;- PERMITS |&gt;\n  dplyr::inner_join(POP2, dplyr::join_by(CBSA, year)) |&gt;\n  dplyr::select(CBSA, NAME, year, new_housing_units_permitted, population)\n\n# 5-year rolling population growth (valid from 2014 onward)\nperm_pop &lt;- perm_pop |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::arrange(year, .by_group = TRUE) |&gt;\n  dplyr::mutate(pop_5y_ago = dplyr::lag(population, 5),\n                pop_growth_5y = population - pop_5y_ago) |&gt;\n  dplyr::ungroup()\n\n# (1) Instant metric: permits per capita\nhg_instant &lt;- perm_pop |&gt;\n  dplyr::mutate(inst_metric = new_housing_units_permitted / population) |&gt;\n  dplyr::group_by(year) |&gt;\n  dplyr::mutate(inst_0100 = 100*(inst_metric - min(inst_metric, na.rm=TRUE)) /\n                              (max(inst_metric, na.rm=TRUE) - min(inst_metric, na.rm=TRUE))) |&gt;\n  dplyr::ungroup()\n\n# (2) Rate metric: permits relative to 5-year population growth\nhg_rate &lt;- perm_pop |&gt;\n  dplyr::mutate(rate_metric = new_housing_units_permitted / pmax(pop_growth_5y, 1)) |&gt;\n  dplyr::group_by(year) |&gt;\n  dplyr::mutate(rate_0100 = 100*(rate_metric - min(rate_metric, na.rm=TRUE)) /\n                              (max(rate_metric, na.rm=TRUE) - min(rate_metric, na.rm=TRUE))) |&gt;\n  dplyr::ungroup()\n\n# Combine to a composite (equal weights by default)\nHG &lt;- hg_instant |&gt;\n  dplyr::select(CBSA, year, inst_0100) |&gt;\n  dplyr::inner_join(hg_rate |&gt; dplyr::select(CBSA, year, rate_0100),\n                    dplyr::join_by(CBSA, year)) |&gt;\n  dplyr::mutate(composite_hg = 0.5*inst_0100 + 0.5*rate_0100)\n\ntop_hg &lt;- HG |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::summarise(mean_hg = mean(composite_hg, na.rm=TRUE), .groups = \"drop\") |&gt;\n  dplyr::arrange(dplyr::desc(mean_hg))\n\nDT::datatable(head(top_hg, 15), caption = \"Top CBSAs by housing growth (composite)\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(top_hg, 15), caption = \"Bottom CBSAs by housing growth (composite)\")"
  },
  {
    "objectID": "mp02.html#task-6-composite-score-yimby-score",
    "href": "mp02.html#task-6-composite-score-yimby-score",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 6 — Composite score (YIMBY Score)",
    "text": "Task 6 — Composite score (YIMBY Score)\n\n\nCode\n# Combine rent burden (lower is better) with housing growth (higher is better)\nrb_cbsa &lt;- rent_tbl |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::summarise(mean_rb0100 = mean(rb_0100, na.rm=TRUE), .groups=\"drop\")\n\nhg_cbsa &lt;- top_hg |&gt;\n  dplyr::select(CBSA, mean_hg)\n\nYIMBY_SCORE &lt;- rb_cbsa |&gt;\n  dplyr::inner_join(hg_cbsa, dplyr::join_by(CBSA)) |&gt;\n  dplyr::mutate(score = (100 - mean_rb0100)*0.5 + mean_hg*0.5) |&gt;\n  dplyr::arrange(dplyr::desc(score))\n\nDT::datatable(head(YIMBY_SCORE, 20), caption = \"Pro‑YIMBY Composite Score — Top 20\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(YIMBY_SCORE, 20), caption = \"Pro‑YIMBY Composite Score — Bottom 20\")"
  },
  {
    "objectID": "mp02.html#task-7-policy-brief-onepage-nontechnical",
    "href": "mp02.html#task-7-policy-brief-onepage-nontechnical",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 7 — Policy Brief (one‑page, non‑technical)",
    "text": "Task 7 — Policy Brief (one‑page, non‑technical)\n\nHeadline cities (pre‑selected, editable): - Pro‑YIMBY sponsor: Phoenix–Mesa–Chandler, AZ (CBSA 38060) — strong recent housing growth. - Co‑sponsor (more NIMBY): San Jose–Sunnyvale–Santa Clara, CA (CBSA 41940) — high rent burden vs income.\nTwo industries to discuss (suggestions): - NAICS 62 (Health & Social Services) — large local employer, benefits from lower rent pressure on workforce. - NAICS 52 (Finance & Insurance) — high‑wage sector; illustrate disposable‑income effects after rent.\nExplain your two metrics in plain English: - Rent burden = annualized rent / household income — lower is better. - Housing growth = permits per capita + permits relative to 5‑year population growth — higher is better.\nYour task: write a one‑page brief here (hide technical chunks with #| echo: false or place prose below)."
  },
  {
    "objectID": "mp02.html#extra-credit-optional",
    "href": "mp02.html#extra-credit-optional",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Extra Credit (optional)",
    "text": "Extra Credit (optional)\n\nEC#02 Spaghetti plot with highlights\n\n\nCode\n# if (requireNamespace(\"gghighlight\", quietly = TRUE)) {\n#   library(gghighlight)\n#   size_ts |&gt;\n#     dplyr::mutate(HILITE = NAME %in% c(\n#       \"Phoenix-Mesa-Chandler, AZ Metro Area\",\n#       \"San Jose-Sunnyvale-Santa Clara, CA Metro Area\"\n#     )) |&gt;\n#     ggplot2::ggplot(ggplot2::aes(year, avg_household_size_est, group = CBSA, color = HILITE)) +\n#     ggplot2::geom_line(alpha = 0.1) +\n#     gghighlight::gghighlight(HILITE) +\n#     ggplot2::guides(color = \"none\") +\n#     ggplot2::labs(title = \"Household Size Over Time — Highlighting Phoenix & San Jose\") +\n#     ggplot2::theme_minimal(base_size = 11)\n# }"
  },
  {
    "objectID": "mp02.html#policy-brief-ready-to-submit",
    "href": "mp02.html#policy-brief-ready-to-submit",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Policy Brief — Ready-to-submit",
    "text": "Policy Brief — Ready-to-submit\n\n“Making Backyards Affordable for All”\nSponsor: Phoenix–Mesa–Chandler, AZ (CBSA 38060)\nCo‑Sponsor: San Jose–Sunnyvale–Santa Clara, CA (CBSA 41940)\nFocus Industries: NAICS 62 (Health & Social Services) and NAICS 52 (Finance & Insurance)\nWhy act now. Across major U.S. metro areas, rent has outpaced incomes for more than a decade. Our analysis combines (1) Rent Burden—annualized median rent divided by median household income—and (2) Housing Growth—a composite of permits per capita and permits relative to 5‑year population growth. Lower rent burden and higher housing growth indicate a more “pro‑housing” environment that supports workers and employers.\nHeadline findings (Phoenix vs. San Jose). Phoenix exhibits consistently higher housing growth and a moderate rent‑to‑income ratio, reflecting robust permitting relative to demand that helps stabilize rents as population expands. San Jose shows elevated rent burden relative to income despite strong wages—signaling supply constraints that erode disposable income and push workers to long commutes or out‑migration.\nWhy these two industries. (a) Health & Social Services (NAICS 62) are large, locally‑rooted employers (hospitals, clinics, senior care). Rent pressure drives staffing shortages and turnover; lowering rent burden improves retention and service coverage. (b) Finance & Insurance (NAICS 52) are high‑wage anchors with spillovers (professional services, restaurants). Stabilizing rents increases disposable income, aiding local businesses and the tax base.\nWhat the bill does (policy levers). 1. Gentle density: by‑right ADUs; duplexes/triplexes on single‑family lots near jobs/transit; small‑scale infill bonuses.\n2. Clock‑and‑fee certainty: statutory review time‑limits; consolidated checklists; capped/transparent impact fees for ≤10‑unit projects.\n3. Permit‑to‑growth alignment: tie local housing targets to permits per capita and permits vs. 5‑year population growth; require remediation plans if targets are missed.\n4. Employer‑linked housing pilots: expedited approvals where employers master‑lease blocks for hospital/public‑safety staff; voluntary down‑payment assistance pools.\n5. Code modernization: flexible parking near transit; allow modular/manufactured ADUs meeting safety standards; fast‑track commercial‑to‑residential conversions.\nMeasuring success (simple, comparable metrics). - Rent Burden (lower is better): annual rent / household income (track median and workforce percentiles).\n- Housing Growth (higher is better): (a) permits per capita; (b) permits vs. 5‑year population growth. Publish yearly dashboards by CBSA.\n- Workforce outcomes: hospital vacancy rates; time‑to‑fill for critical roles; retention in NAICS 62 & 52.\nEquity & safeguards. Production without displacement (right‑to‑return, relocation aid, anti‑gouging during major rehabs). Community benefits: a share of small‑infill units reserved at 80–120% AMI with simple compliance to avoid deterring production.\nCall to action. Phoenix can model modest, predictable approvals that match population growth. San Jose can show how easing small‑scale infill and right‑sizing fees reduces rent burden in high‑productivity regions. Together, these metros can prove incremental, rules‑based reforms make housing more abundant, affordable, and closer to jobs—supporting patients, families, and employers."
  },
  {
    "objectID": "mp02.html#task-2-joins-example-queries",
    "href": "mp02.html#task-2-joins-example-queries",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 2 — Joins & Example Queries",
    "text": "Task 2 — Joins & Example Queries\n\n\nCode\n# Task 2 Answers — with English comments & DT tables\nif (!requireNamespace(\"DT\", quietly = TRUE)) install.packages(\"DT\")\nlibrary(DT)\n\n.ok &lt;- function(x) !is.null(x) && is.data.frame(x) && nrow(x) &gt; 0\nreq_ok &lt;- all(\n  exists(\"PERMITS\", inherits = FALSE),\n  exists(\"RENT2\",   inherits = FALSE),\n  exists(\"INCOME2\", inherits = FALSE),\n  exists(\"POP2\",    inherits = FALSE)\n)\n\nif (!req_ok) {\n  cat(\"⚠️ Task 2 skipped: missing PERMITS / RENT2 / INCOME2 / POP2.\\n\")\n} else {\n\n  # Make sure ACS_RI exists (should already be built)\n  if (!.ok(ACS_RI)) {\n    ACS_RI &lt;- RENT2 |&gt;\n      dplyr::select(CBSA, NAME, year, monthly_rent) |&gt;\n      dplyr::inner_join(\n        INCOME2 |&gt; dplyr::select(CBSA, year, household_income),\n        by = c(\"CBSA\",\"year\")\n      )\n  }\n\n  # Q1\n  cat(\"**Task 2 — Q1: 2010–2019 Permits Leader**\\n\")\n  ans1 &lt;- PERMITS |&gt;\n    dplyr::filter(dplyr::between(year, 2010, 2019)) |&gt;\n    dplyr::group_by(CBSA) |&gt;\n    dplyr::summarise(total_permits = sum(new_housing_units_permitted, na.rm = TRUE), .groups = \"drop\") |&gt;\n    dplyr::arrange(dplyr::desc(total_permits)) |&gt;\n    dplyr::left_join(ACS_RI |&gt; dplyr::distinct(CBSA, NAME), by = \"CBSA\") |&gt;\n    dplyr::select(NAME, CBSA, total_permits)\n  if (.ok(ans1)) DT::datatable(head(ans1, 10), rownames = FALSE, options = list(pageLength = 5)) |&gt; DT::formatRound(\"total_permits\", 0) else cat(\"No data.\\n\")\n\n  # Q2\n  cat(\"\\n**Task 2 — Q2: NYC & LA Peak Permit Year**\\n\")\n  ans2 &lt;- PERMITS |&gt;\n    dplyr::filter(CBSA == 38060) |&gt;\n    dplyr::arrange(dplyr::desc(new_housing_units_permitted)) |&gt;\n    dplyr::slice_head(n = 1) |&gt;\n    dplyr::left_join(ACS_RI |&gt; dplyr::distinct(CBSA, NAME), by = \"CBSA\") |&gt;\n    dplyr::select(NAME, year, new_housing_units_permitted)\n  if (.ok(ans2)) DT::datatable(ans2, rownames = FALSE, options = list(dom = 't')) else cat(\"No NYC/LA rows.\\n\")\n\n  # Q3\n  cat(\"\\n**Task 2 — Q3: Highest Average Rent Burden (2014–2023)**\\n\")\n  ans3 &lt;- ACS_RI |&gt;\n    dplyr::mutate(rent_to_income = (monthly_rent * 12) / household_income) |&gt;\n    dplyr::filter(dplyr::between(year, 2014, 2023)) |&gt;\n    dplyr::group_by(CBSA, NAME) |&gt;\n    dplyr::summarise(mean_RB = mean(rent_to_income, na.rm = TRUE), .groups = \"drop\") |&gt;\n    dplyr::arrange(dplyr::desc(mean_RB))\n  if (.ok(ans3)) DT::datatable(head(ans3, 10), rownames = FALSE, options = list(pageLength = 5)) |&gt; DT::formatPercentage(\"mean_RB\", 2) else cat(\"No ACS rent/income.\\n\")\n\n  # Q4\n  cat(\"\\n**Task 2 — Q4: 2009 Rent–Income Correlation and Slope**\\n\")\n  ri_2009 &lt;- ACS_RI |&gt; dplyr::filter(year == 2009)\n  if (.ok(ri_2009)) {\n    cor_ri &lt;- suppressWarnings(stats::cor(ri_2009$household_income, ri_2009$monthly_rent, use = \"pairwise.complete.obs\"))\n    fit &lt;- tryCatch(stats::lm(monthly_rent ~ household_income, data = ri_2009), error = function(e) NULL)\n    slope &lt;- if (is.null(fit)) NA_real_ else unname(stats::coef(fit)[2])\n    tbl4 &lt;- data.frame(correlation_2009 = cor_ri, slope_dollars_per_income = slope)\n    DT::datatable(tbl4, rownames = FALSE, options = list(dom = 't')) |&gt;\n      DT::formatRound(c(\"correlation_2009\", \"slope_dollars_per_income\"), 4)\n  } else cat(\"No 2009 ACS rows.\\n\")\n\n  # Q5\n  cat(\"\\n**Task 2 — Q5: Top Composite Housing Growth CBSAs (2014–2023)**\\n\")\n  perm_pop &lt;- PERMITS |&gt;\n    dplyr::inner_join(POP2, dplyr::join_by(CBSA, year)) |&gt;\n    dplyr::select(CBSA, year, new_housing_units_permitted, population) |&gt;\n    dplyr::group_by(CBSA) |&gt;\n    dplyr::arrange(year, .by_group = TRUE) |&gt;\n    dplyr::mutate(pop_5y_ago = dplyr::lag(population, 5),\n                  pop_growth_5y = population - pop_5y_ago) |&gt;\n    dplyr::ungroup()\n\n  if (.ok(perm_pop)) {\n    hg_instant &lt;- perm_pop |&gt;\n      dplyr::mutate(inst = new_housing_units_permitted / population) |&gt;\n      dplyr::filter(dplyr::between(year, 2014, 2023)) |&gt;\n      dplyr::group_by(year) |&gt;\n      dplyr::mutate(inst_0100 = 100 * (inst - min(inst, na.rm=TRUE)) / (max(inst, na.rm=TRUE) - min(inst, na.rm=TRUE))) |&gt;\n      dplyr::ungroup()\n\n    hg_rate &lt;- perm_pop |&gt;\n      dplyr::mutate(rate = new_housing_units_permitted / pmax(pop_growth_5y, 1)) |&gt;\n      dplyr::filter(dplyr::between(year, 2014, 2023)) |&gt;\n      dplyr::group_by(year) |&gt;\n      dplyr::mutate(rate_0100 = 100 * (rate - min(rate, na.rm=TRUE)) / (max(rate, na.rm=TRUE) - min(rate, na.rm=TRUE))) |&gt;\n      dplyr::ungroup()\n\n    HG &lt;- hg_instant |&gt;\n      dplyr::select(CBSA, year, inst_0100) |&gt;\n      dplyr::inner_join(hg_rate |&gt; dplyr::select(CBSA, year, rate_0100), by = c(\"CBSA\",\"year\")) |&gt;\n      dplyr::mutate(hg_composite = 0.5*inst_0100 + 0.5*rate_0100)\n\n    ans5 &lt;- HG |&gt;\n      dplyr::group_by(CBSA) |&gt;\n      dplyr::summarise(mean_hg_2014_2023 = mean(hg_composite, na.rm = TRUE), .groups = \"drop\") |&gt;\n      dplyr::arrange(dplyr::desc(mean_hg_2014_2023)) |&gt;\n      dplyr::left_join(ACS_RI |&gt; dplyr::distinct(CBSA, NAME), by = \"CBSA\") |&gt;\n      dplyr::select(NAME, CBSA, mean_hg_2014_2023)\n\n    if (.ok(ans5)) {\n      DT::datatable(head(ans5, 10), rownames = FALSE, options = list(pageLength = 5)) |&gt;\n        DT::formatRound(\"mean_hg_2014_2023\", 2)\n    } else cat(\"No composite rows.\\n\")\n  } else {\n    cat(\"PERMITS + POP join empty.\\n\")\n  }\n}\n\n\n⚠️ Task 2 skipped: missing PERMITS / RENT2 / INCOME2 / POP2."
  },
  {
    "objectID": "mp02.html#task-1-data-import",
    "href": "mp02.html#task-1-data-import",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 1 — Data import",
    "text": "Task 1 — Data import\n\n\nCode\n# Helper: download ACS across years (cached to CSV). Skips 2020 per instructor.\nget_acs_all_years &lt;- function(variable, geography=\"cbsa\", start_year=2009, end_year=2023){\n  fname &lt;- glue(\"{variable}_{geography}_{start_year}_{end_year}.csv\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n  if(!file.exists(fname)){\n    YEARS &lt;- seq(start_year, end_year)\n    YEARS &lt;- YEARS[YEARS != 2020]  # Skip 2020 (COVID data gap)\n    ALL_DATA &lt;- purrr::map(YEARS, function(yy){\n      tidycensus::get_acs(geography, variable, year=yy, survey=\"acs1\") |&gt;\n        dplyr::mutate(year=yy) |&gt;\n        dplyr::select(-moe, -variable) |&gt;\n        dplyr::rename(!!variable := estimate)\n    }) |&gt;\n      dplyr::bind_rows()\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\n\n# Median household income, median gross rent, total population, total households\nINCOME &lt;- get_acs_all_years(\"B19013_001\") |&gt; dplyr::rename(household_income = B19013_001)\nRENT   &lt;- get_acs_all_years(\"B25064_001\") |&gt; dplyr::rename(monthly_rent     = B25064_001)\nPOP    &lt;- get_acs_all_years(\"B01003_001\") |&gt; dplyr::rename(population       = B01003_001)\nHH     &lt;- get_acs_all_years(\"B11001_001\") |&gt; dplyr::rename(households       = B11001_001)\n\n\n\n\nCode\n# Building permits (historical text + recent Excel), cached to CSV.\nget_building_permits &lt;- function(start_year = 2009, end_year = 2023){\n  fname &lt;- glue(\"housing_units_{start_year}_{end_year}.csv\")\n  fname &lt;- file.path(\"data\", \"mp02\", fname)\n  if(!file.exists(fname)){\n    # Historical TXT format up to 2018\n    HISTORICAL_YEARS &lt;- seq(start_year, 2018)\n    HISTORICAL_DATA &lt;- purrr::map(HISTORICAL_YEARS, function(yy){\n      historical_url &lt;- glue(\"https://www.census.gov/construction/bps/txt/tb3u{yy}.txt\")\n      LINES &lt;- readLines(historical_url)[-c(1:11)]\n      CBSA_LINES &lt;- stringr::str_detect(LINES, \"^[[:digit:]]\")\n      CBSA &lt;- as.integer(stringr::str_sub(LINES[CBSA_LINES], 5, 10))\n      PERMIT_LINES &lt;- stringr::str_detect(stringr::str_sub(LINES, 48, 53), \"[[:digit:]]\")\n      PERMITS &lt;- as.integer(stringr::str_sub(LINES[PERMIT_LINES], 48, 53))\n      tibble::tibble(CBSA = CBSA, new_housing_units_permitted = PERMITS, year = yy)\n    }) |&gt;\n      dplyr::bind_rows()\n\n    # Excel format from 2019 onward\n    CURRENT_YEARS &lt;- seq(2019, end_year)\n    CURRENT_DATA &lt;- purrr::map(CURRENT_YEARS, function(yy){\n      current_url &lt;- glue(\"https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls\")\n      temp &lt;- tempfile()\n      download.file(current_url, destfile = temp, mode = \"wb\")\n      reader &lt;- function(...) tryCatch(readxl::read_xlsx(...), error=function(e) readxl::read_xls(...))\n      reader(temp, skip = 5) |&gt;\n        tidyr::drop_na() |&gt;\n        dplyr::select(CBSA, Total) |&gt;\n        dplyr::mutate(year = yy) |&gt;\n        dplyr::rename(new_housing_units_permitted = Total)\n    }) |&gt;\n      dplyr::bind_rows()\n\n    ALL_DATA &lt;- dplyr::bind_rows(HISTORICAL_DATA, CURRENT_DATA)\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nPERMITS &lt;- get_building_permits()\n\n\n\n\nCode\n# Robust BLS NAICS titles + QCEW download with graceful fallback (knitr version)\n\nautoinstall &lt;- function(pkg){\n  pkg &lt;- as.character(substitute(pkg))\n  if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)\n  stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))\n}\nautoinstall(httr2); autoinstall(rvest); autoinstall(readr); autoinstall(dplyr); autoinstall(stringr); autoinstall(tidyr)\n\nget_bls_industry_codes &lt;- function(){\n  fname &lt;- file.path(\"data\", \"mp02\", \"bls_industry_codes.csv\")\n  if(file.exists(fname)){\n    out &lt;- tryCatch(readr::read_csv(fname, show_col_types = FALSE), error = function(e) NULL)\n    if(!is.null(out)) return(out)\n  }\n  scraped &lt;- tryCatch({\n    resp &lt;- httr2::request(\"https://www.bls.gov\") |&gt;\n      httr2::req_url_path(\"cew\", \"classifications\", \"industry\", \"industry-titles.htm\") |&gt;\n      httr2::req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n      httr2::req_perform()\n    node &lt;- httr2::resp_body_html(resp) |&gt;\n      rvest::html_element(\"#naics_titles\")\n    if (is.null(node)) stop(\"NAICS table node not found on page\")\n    tbl  &lt;- rvest::html_table(node)\n    tbl  &lt;- tbl |&gt;\n      dplyr::mutate(title = stringr::str_trim(stringr::str_remove(stringr::str_remove(`Industry Title`, Code), \"NAICS\"))) |&gt;\n      dplyr::select(-`Industry Title`) |&gt;\n      dplyr::mutate(depth = ifelse(nchar(Code) &lt;= 5, nchar(Code) - 1, NA)) |&gt;\n      dplyr::filter(!is.na(depth))\n    naics_missing &lt;- tibble::tribble(\n      ~Code, ~title, ~depth,\n      \"31\",\"Manufacturing\",1, \"32\",\"Manufacturing\",1, \"33\",\"Manufacturing\",1,\n      \"44\",\"Retail\",1,        \"45\",\"Retail\",1,\n      \"48\",\"Transportation and Warehousing\",1, \"49\",\"Transportation and Warehousing\",1\n    )\n    lev &lt;- dplyr::bind_rows(tbl, naics_missing) |&gt;\n      dplyr::filter(depth == 4) |&gt;\n      dplyr::rename(level4_title = title) |&gt;\n      dplyr::mutate(level1_code = stringr::str_sub(Code, end=2),\n                    level2_code = stringr::str_sub(Code, end=3),\n                    level3_code = stringr::str_sub(Code, end=4)) |&gt;\n      dplyr::left_join(tbl, dplyr::join_by(level1_code == Code)) |&gt;\n      dplyr::rename(level1_title = title) |&gt;\n      dplyr::left_join(tbl, dplyr::join_by(level2_code == Code)) |&gt;\n      dplyr::rename(level2_title = title) |&gt;\n      dplyr::left_join(tbl, dplyr::join_by(level3_code == Code)) |&gt;\n      dplyr::rename(level3_title = title) |&gt;\n      dplyr::select(-dplyr::starts_with(\"depth\")) |&gt;\n      dplyr::rename(level4_code = Code) |&gt;\n      dplyr::select(level1_title, level2_title, level3_title, level4_title,\n                    level1_code,  level2_code,  level3_code,  level4_code) |&gt;\n      tidyr::drop_na() |&gt;\n      dplyr::mutate(dplyr::across(dplyr::contains(\"code\"), as.integer))\n    readr::write_csv(lev, fname)\n    lev\n  }, error = function(e) NULL)\n\n  if(is.null(scraped)){\n    fallback &lt;- tibble::tibble(\n      level1_title = c(\"Finance and Insurance\", \"Health Care and Social Assistance\", \"Information\"),\n      level2_title = c(NA, NA, NA),\n      level3_title = c(NA, NA, NA),\n      level4_title = c(\"Finance and Insurance\", \"Health Care and Social Assistance\", \"Data Processing, Hosting, and Related Services\"),\n      level1_code  = c(52L, 62L, 51L),\n      level2_code  = c(NA, NA, NA),\n      level3_code  = c(NA, NA, NA),\n      level4_code  = c(52L, 62L, 5182L)\n    )\n    readr::write_csv(fallback, fname)\n    return(fallback)\n  }\n  scraped\n}\n\nINDUSTRY_CODES &lt;- get_bls_industry_codes()\n\nget_bls_qcew_annual_averages &lt;- function(start_year=2009, end_year=2023){\n  fname &lt;- glue::glue(\"bls_qcew_{start_year}_{end_year}.csv.gz\")\n  fname &lt;- file.path(\"data\",\"mp02\", fname)\n  YEARS &lt;- setdiff(seq(start_year, end_year), 2020)\n  if(!file.exists(fname)){\n    ALL_DATA &lt;- purrr::map(YEARS, purrr::possibly(function(yy){\n      zpath &lt;- file.path(\"data\",\"mp02\", glue::glue(\"{yy}_qcew_annual_singlefile.zip\"))\n      if(!file.exists(zpath)){\n        httr2::request(\"https://www.bls.gov\") |&gt;\n          httr2::req_url_path(\"cew\",\"data\",\"files\", yy, \"csv\", glue::glue(\"{yy}_annual_singlefile.zip\")) |&gt;\n          httr2::req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n          httr2::req_retry(max_tries = 5) |&gt;\n          httr2::req_perform(zpath)\n      }\n      tmpdir &lt;- file.path(\"data\",\"mp02\", glue::glue(\"unz_{yy}\"))\n      if(!dir.exists(tmpdir)) dir.create(tmpdir, recursive = TRUE, showWarnings = FALSE)\n      utils::unzip(zpath, exdir = tmpdir)\n      target &lt;- list.files(tmpdir, pattern = \"annual_singlefile.csv$\", full.names = TRUE)\n      readr::read_csv(target, show_col_types = FALSE) |&gt;\n        dplyr::mutate(YEAR = yy) |&gt;\n        dplyr::select(area_fips, industry_code, annual_avg_emplvl, total_annual_wages, YEAR) |&gt;\n        dplyr::filter(nchar(industry_code) &lt;= 5, stringr::str_starts(area_fips, \"C\")) |&gt;\n        dplyr::filter(!stringr::str_detect(industry_code, \"-\")) |&gt;\n        dplyr::mutate(FIPS = area_fips,\n                      INDUSTRY = as.integer(industry_code),\n                      EMPLOYMENT = as.integer(annual_avg_emplvl),\n                      TOTAL_WAGES = total_annual_wages) |&gt;\n        dplyr::select(-area_fips, -industry_code, -annual_avg_emplvl, -total_annual_wages) |&gt;\n        dplyr::filter(INDUSTRY != 10) |&gt;\n        dplyr::mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)\n    }, NULL)) |&gt;\n      dplyr::bind_rows()\n    readr::write_csv(ALL_DATA, fname)\n  }\n  readr::read_csv(fname, show_col_types = FALSE)\n}\nWAGES &lt;- get_bls_qcew_annual_averages()\n\n\n\n\nCode\n# Ensure numeric types for QCEW before any summaries/plots\nWAGES &lt;- WAGES |&gt;\n  dplyr::mutate(\n    EMPLOYMENT  = suppressWarnings(as.numeric(EMPLOYMENT)),\n    TOTAL_WAGES = suppressWarnings(as.numeric(TOTAL_WAGES)),\n    YEAR        = suppressWarnings(as.integer(YEAR)),\n    INDUSTRY    = suppressWarnings(as.integer(INDUSTRY))\n  )\nWAGES &lt;- dplyr::filter(WAGES, !is.na(EMPLOYMENT))\nWAGES2 &lt;- WAGES |&gt;\n  dplyr::mutate(CBSA = as.double(stringr::str_remove(FIPS, \"^C\")) * 10)"
  },
  {
    "objectID": "mp02.html#task-2-multi-table-questions",
    "href": "mp02.html#task-2-multi-table-questions",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 2 — Multi-Table Questions",
    "text": "Task 2 — Multi-Table Questions\n\n\nCode\n# Normalize ACS tables to a common key\nnormalize_acs &lt;- function(df) df |&gt;\n  dplyr::rename(CBSA = GEOID) |&gt;\n  dplyr::select(CBSA, NAME, year, dplyr::everything())\n\nINCOME2 &lt;- normalize_acs(INCOME)\nRENT2   &lt;- normalize_acs(RENT)\nPOP2    &lt;- normalize_acs(POP)\nHH2     &lt;- normalize_acs(HH)\n\n# Rent + income merged table (keep a single NAME)\nACS_RI &lt;- RENT2 |&gt;\n  dplyr::select(CBSA, NAME, year, monthly_rent) |&gt;\n  dplyr::inner_join(\n    INCOME2 |&gt; dplyr::select(CBSA, year, household_income),\n    by = c(\"CBSA\",\"year\")\n  )\n\n# Example Q1: 2010–2019, which CBSA permitted the most housing units?\nperm_2010_2019 &lt;- PERMITS |&gt;\n  dplyr::filter(dplyr::between(year, 2010, 2019)) |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::summarise(total_permits = sum(new_housing_units_permitted, na.rm=TRUE), .groups=\"drop\") |&gt;\n  dplyr::arrange(dplyr::desc(total_permits))\n\n# Example Q2: Albuquerque (CBSA 10740) — peak permit year\nalbq_peak &lt;- PERMITS |&gt;\n  dplyr::filter(CBSA == 10740) |&gt;\n  dplyr::arrange(dplyr::desc(new_housing_units_permitted)) |&gt;\n  dplyr::slice(1)\n\n# BLS uses 'C####' market codes: convert to Census 5-digit CBSA by removing 'C' and x10.\nWAGES2 &lt;- WAGES |&gt;\n  dplyr::mutate(CBSA = as.double(stringr::str_remove(FIPS, \"^C\")) * 10)"
  },
  {
    "objectID": "mp02.html#task-3-first-visuals",
    "href": "mp02.html#task-3-first-visuals",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 3 — First visuals",
    "text": "Task 3 — First visuals\n\n\nCode\n# (1) 2009 scatter: rent vs. household income\nri_2009 &lt;- ACS_RI |&gt; dplyr::filter(year == 2009)\n\nri_2009 |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = household_income, y = monthly_rent)) +\n  ggplot2::geom_point(alpha = 0.6) +\n  ggplot2::scale_x_continuous(labels = scales::label_dollar()) +\n  ggplot2::scale_y_continuous(labels = scales::label_dollar(suffix=\"/mo\")) +\n  ggplot2::labs(\n    x = \"Median Household Income (ACS)\",\n    y = \"Median Gross Rent (ACS)\",\n    title = \"Rent vs Income by CBSA (2009)\",\n    subtitle = \"ACS 1-year estimates\"\n  ) +\n  ggplot2::theme_minimal(base_size = 12)\n\n\n\n\n\n\n\n\n\nCode\n# (2) Health sector vs total employment — robust summary (no pivot + safe faceting)\nhealth_cbsa &lt;- WAGES2 |&gt;\n  dplyr::filter(!is.na(YEAR), !is.na(CBSA)) |&gt;\n  dplyr::group_by(YEAR, CBSA) |&gt;\n  dplyr::summarise(\n    EMP_ALL    = sum(as.numeric(EMPLOYMENT), na.rm = TRUE),\n    EMP_HEALTH = sum(as.numeric(EMPLOYMENT) * (INDUSTRY == 62), na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nif (nrow(health_cbsa) &gt; 0 && any(!is.na(health_cbsa$YEAR))) {\n  health_cbsa |&gt;\n    ggplot2::ggplot(ggplot2::aes(x = EMP_ALL, y = EMP_HEALTH)) +\n    ggplot2::geom_point(alpha = 0.3) +\n    ggplot2::facet_wrap(~ YEAR, ncol = 4) +\n    ggplot2::scale_x_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n    ggplot2::scale_y_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n    ggplot2::labs(\n      x = \"Total Employment (QCEW)\",\n      y = \"Health & Social Services Employment (NAICS 62)\",\n      title = \"Health Sector Employment vs Overall Employment by CBSA (QCEW)\"\n    ) +\n    ggplot2::theme_minimal(base_size = 11)\n} else {\n  cat(\"Note: QCEW table is empty (or all YEAR are NA) on this machine, so the facet plot is skipped.\\n\",\n      \"You can still proceed with ACS and Permits sections, and Policy Brief.\\n\")\n}\n\n\nNote: QCEW table is empty (or all YEAR are NA) on this machine, so the facet plot is skipped.\n You can still proceed with ACS and Permits sections, and Policy Brief.\n\n\nCode\n# (3) Average household size (rough estimate) time series\nsize_ts &lt;- POP2 |&gt;\n  dplyr::inner_join(HH2, dplyr::join_by(CBSA, NAME, year)) |&gt;\n  dplyr::mutate(avg_household_size_est = dplyr::if_else(households &gt; 0, population/households, NA_real_))\n\nsize_ts |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = year, y = avg_household_size_est, group = CBSA)) +\n  ggplot2::geom_line(alpha = 0.15) +\n  ggplot2::labs(\n    x = NULL, y = \"Avg Household Size (rough est.)\",\n    title = \"Average Household Size by CBSA over Time\"\n  ) +\n  ggplot2::theme_minimal(base_size = 11)"
  },
  {
    "objectID": "mp02.html#task-4-rent-burden-index",
    "href": "mp02.html#task-4-rent-burden-index",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 4 — Rent burden index",
    "text": "Task 4 — Rent burden index\n\n\nCode\nrent_tbl &lt;- ACS_RI |&gt;\n  dplyr::mutate(rent_to_income = (monthly_rent*12) / household_income) |&gt;\n  dplyr::group_by(year) |&gt;\n  dplyr::mutate(\n    rb_z = (rent_to_income - mean(rent_to_income, na.rm=TRUE)) / sd(rent_to_income, na.rm=TRUE),\n    rb_0100 = 100*(rent_to_income - min(rent_to_income, na.rm=TRUE)) /\n                    (max(rent_to_income, na.rm=TRUE) - min(rent_to_income, na.rm=TRUE))\n  ) |&gt;\n  dplyr::ungroup()\n\n# Show: a selected CBSA's trend + global high/low tables\n# Pre-selected headline CBSAs (you can change if you want):\nselected_cbsa_yimby &lt;- 38060  # Phoenix–Mesa–Chandler, AZ\nselected_cbsa_nimby &lt;- 41940  # San Jose–Sunnyvale–Santa Clara, CA\n\nrent_one_y &lt;- rent_tbl |&gt; dplyr::filter(CBSA == selected_cbsa_yimby) |&gt;\n  dplyr::select(NAME, year, rent_to_income, rb_z, rb_0100)\nrent_one_n &lt;- rent_tbl |&gt; dplyr::filter(CBSA == selected_cbsa_nimby) |&gt;\n  dplyr::select(NAME, year, rent_to_income, rb_z, rb_0100)\n\nDT::datatable(rent_one_y, caption = \"Rent burden over time — Phoenix–Mesa–Chandler, AZ\")\n\n\n\n\n\n\nCode\nDT::datatable(rent_one_n, caption = \"Rent burden over time — San Jose–Sunnyvale–Santa Clara, CA\")\n\n\n\n\n\n\nCode\nhigh_low &lt;- rent_tbl |&gt;\n  dplyr::group_by(CBSA, NAME) |&gt;\n  dplyr::summarise(mean_rb = mean(rent_to_income, na.rm=TRUE), .groups = \"drop\") |&gt;\n  dplyr::arrange(dplyr::desc(mean_rb))\n\nDT::datatable(head(high_low, 10), caption = \"Highest rent burden CBSAs (mean over years)\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(high_low, 10), caption = \"Lowest rent burden CBSAs (mean over years)\")"
  },
  {
    "objectID": "mp02.html#task-5-housing-growth-index",
    "href": "mp02.html#task-5-housing-growth-index",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 5 — Housing growth index",
    "text": "Task 5 — Housing growth index\n\n\nCode\nperm_pop &lt;- PERMITS |&gt;\n  dplyr::inner_join(POP2, dplyr::join_by(CBSA, year)) |&gt;\n  dplyr::select(CBSA, NAME, year, new_housing_units_permitted, population)\n\n# 5-year rolling population growth (valid from 2014 onward)\nperm_pop &lt;- perm_pop |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::arrange(year, .by_group = TRUE) |&gt;\n  dplyr::mutate(pop_5y_ago = dplyr::lag(population, 5),\n                pop_growth_5y = population - pop_5y_ago) |&gt;\n  dplyr::ungroup()\n\n# (1) Instant metric: permits per capita\nhg_instant &lt;- perm_pop |&gt;\n  dplyr::mutate(inst_metric = new_housing_units_permitted / population) |&gt;\n  dplyr::group_by(year) |&gt;\n  dplyr::mutate(inst_0100 = 100*(inst_metric - min(inst_metric, na.rm=TRUE)) /\n                              (max(inst_metric, na.rm=TRUE) - min(inst_metric, na.rm=TRUE))) |&gt;\n  dplyr::ungroup()\n\n# (2) Rate metric: permits relative to 5-year population growth\nhg_rate &lt;- perm_pop |&gt;\n  dplyr::mutate(rate_metric = new_housing_units_permitted / pmax(pop_growth_5y, 1)) |&gt;\n  dplyr::group_by(year) |&gt;\n  dplyr::mutate(rate_0100 = 100*(rate_metric - min(rate_metric, na.rm=TRUE)) /\n                              (max(rate_metric, na.rm=TRUE) - min(rate_metric, na.rm=TRUE))) |&gt;\n  dplyr::ungroup()\n\n# Combine to a composite (equal weights by default)\nHG &lt;- hg_instant |&gt;\n  dplyr::select(CBSA, year, inst_0100) |&gt;\n  dplyr::inner_join(hg_rate |&gt; dplyr::select(CBSA, year, rate_0100),\n                    dplyr::join_by(CBSA, year)) |&gt;\n  dplyr::mutate(composite_hg = 0.5*inst_0100 + 0.5*rate_0100)\n\ntop_hg &lt;- HG |&gt;\n  dplyr::group_by(CBSA) |&gt;\n  dplyr::summarise(mean_hg = mean(composite_hg, na.rm=TRUE), .groups = \"drop\") |&gt;\n  dplyr::arrange(dplyr::desc(mean_hg))\n\nDT::datatable(head(top_hg, 15), caption = \"Top CBSAs by housing growth (composite)\")\n\n\n\n\n\n\nCode\nDT::datatable(tail(top_hg, 15), caption = \"Bottom CBSAs by housing growth (composite)\")"
  },
  {
    "objectID": "mp02.html#policy-brief",
    "href": "mp02.html#policy-brief",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Policy Brief",
    "text": "Policy Brief\n\n“Making Backyards Affordable for All”\nSponsor: Phoenix–Mesa–Chandler, AZ (CBSA 38060)\nCo‑Sponsor: San Jose–Sunnyvale–Santa Clara, CA (CBSA 41940)\nFocus Industries: NAICS 62 (Health & Social Services) and NAICS 52 (Finance & Insurance)\nWhy act now. Across major U.S. metro areas, rent has outpaced incomes for more than a decade. Our analysis combines (1) Rent Burden—annualized median rent divided by median household income—and (2) Housing Growth—a composite of permits per capita and permits relative to 5‑year population growth. Lower rent burden and higher housing growth indicate a more “pro‑housing” environment that supports workers and employers.\nHeadline findings (Phoenix vs. San Jose). Phoenix exhibits consistently higher housing growth and a moderate rent‑to‑income ratio, reflecting robust permitting relative to demand that helps stabilize rents as population expands. San Jose shows elevated rent burden relative to income despite strong wages—signaling supply constraints that erode disposable income and push workers to long commutes or out‑migration.\nWhy these two industries. (a) Health & Social Services (NAICS 62) are large, locally‑rooted employers (hospitals, clinics, senior care). Rent pressure drives staffing shortages and turnover; lowering rent burden improves retention and service coverage. (b) Finance & Insurance (NAICS 52) are high‑wage anchors with spillovers (professional services, restaurants). Stabilizing rents increases disposable income, aiding local businesses and the tax base.\nWhat the bill does (policy levers). 1. Gentle density: by‑right ADUs; duplexes/triplexes on single‑family lots near jobs/transit; small‑scale infill bonuses.\n2. Clock‑and‑fee certainty: statutory review time‑limits; consolidated checklists; capped/transparent impact fees for ≤10‑unit projects.\n3. Permit‑to‑growth alignment: tie local housing targets to permits per capita and permits vs. 5‑year population growth; require remediation plans if targets are missed.\n4. Employer‑linked housing pilots: expedited approvals where employers master‑lease blocks for hospital/public‑safety staff; voluntary down‑payment assistance pools.\n5. Code modernization: flexible parking near transit; allow modular/manufactured ADUs meeting safety standards; fast‑track commercial‑to‑residential conversions.\nMeasuring success (simple, comparable metrics). - Rent Burden (lower is better): annual rent / household income (track median and workforce percentiles).\n- Housing Growth (higher is better): (a) permits per capita; (b) permits vs. 5‑year population growth. Publish yearly dashboards by CBSA.\n- Workforce outcomes: hospital vacancy rates; time‑to‑fill for critical roles; retention in NAICS 62 & 52.\nEquity & safeguards. Production without displacement (right‑to‑return, relocation aid, anti‑gouging during major rehabs). Community benefits: a share of small‑infill units reserved at 80–120% AMI with simple compliance to avoid deterring production.\nCall to action. Phoenix can model modest, predictable approvals that match population growth. San Jose can show how easing small‑scale infill and right‑sizing fees reduces rent burden in high‑productivity regions. Together, these metros can prove incremental, rules‑based reforms make housing more abundant, affordable, and closer to jobs—supporting patients, families, and employers."
  },
  {
    "objectID": "mp02.html#task-3-initial-visualizations",
    "href": "mp02.html#task-3-initial-visualizations",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 3 — Initial Visualizations",
    "text": "Task 3 — Initial Visualizations\n\n\nCode\n# (1) 2009 scatter: rent vs. household income\nri_2009 &lt;- ACS_RI |&gt; dplyr::filter(year == 2009)\n\nri_2009 |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = household_income, y = monthly_rent)) +\n  ggplot2::geom_point(alpha = 0.6) +\n  ggplot2::scale_x_continuous(labels = scales::label_dollar()) +\n  ggplot2::scale_y_continuous(labels = scales::label_dollar(suffix=\"/mo\")) +\n  ggplot2::labs(\n    x = \"Median Household Income (ACS)\",\n    y = \"Median Gross Rent (ACS)\",\n    title = \"Rent vs Income by CBSA (2009)\",\n    subtitle = \"ACS 1-year estimates\"\n  ) +\n  ggplot2::theme_minimal(base_size = 12)\n\n\n\n\n\n\n\n\n\nCode\n# (2) Health sector vs total employment — robust summary (no pivot + safe faceting)\nhealth_cbsa &lt;- WAGES2 |&gt;\n  dplyr::filter(!is.na(YEAR), !is.na(CBSA)) |&gt;\n  dplyr::group_by(YEAR, CBSA) |&gt;\n  dplyr::summarise(\n    EMP_ALL    = sum(as.numeric(EMPLOYMENT), na.rm = TRUE),\n    EMP_HEALTH = sum(as.numeric(EMPLOYMENT) * (INDUSTRY == 62), na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nif (nrow(health_cbsa) &gt; 0 && any(!is.na(health_cbsa$YEAR))) {\n  health_cbsa |&gt;\n    ggplot2::ggplot(ggplot2::aes(x = EMP_ALL, y = EMP_HEALTH)) +\n    ggplot2::geom_point(alpha = 0.3) +\n    ggplot2::facet_wrap(~ YEAR, ncol = 4) +\n    ggplot2::scale_x_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n    ggplot2::scale_y_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n    ggplot2::labs(\n      x = \"Total Employment (QCEW)\",\n      y = \"Health & Social Services Employment (NAICS 62)\",\n      title = \"Health Sector Employment vs Overall Employment by CBSA (QCEW)\"\n    ) +\n    ggplot2::theme_minimal(base_size = 11)\n} else {\n  cat(\"Note: QCEW table is empty (or all YEAR are NA) on this machine, so the facet plot is skipped.\\n\",\n      \"You can still proceed with ACS and Permits sections, and Policy Brief.\\n\")\n}\n\n\nNote: QCEW table is empty (or all YEAR are NA) on this machine, so the facet plot is skipped.\n You can still proceed with ACS and Permits sections, and Policy Brief.\n\n\nCode\n# (3) Average household size (rough estimate) time series\nsize_ts &lt;- POP2 |&gt;\n  dplyr::inner_join(HH2, dplyr::join_by(CBSA, NAME, year)) |&gt;\n  dplyr::mutate(avg_household_size_est = dplyr::if_else(households &gt; 0, population/households, NA_real_))\n\nsize_ts |&gt;\n  ggplot2::ggplot(ggplot2::aes(x = year, y = avg_household_size_est, group = CBSA)) +\n  ggplot2::geom_line(alpha = 0.15) +\n  ggplot2::labs(\n    x = NULL, y = \"Avg Household Size (rough est.)\",\n    title = \"Average Household Size by CBSA over Time\"\n  ) +\n  ggplot2::theme_minimal(base_size = 11)"
  },
  {
    "objectID": "mp02.html#task-1-data-assembly-robust",
    "href": "mp02.html#task-1-data-assembly-robust",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 1 — Data Assembly (Robust)",
    "text": "Task 1 — Data Assembly (Robust)\n\n1.1 ACS (Rent/Income/Population/Households)\n\n\nCode\n# Build ACS tables with strong guards; always create objects.\n\nempty_tbl &lt;- function(cols, types) {\n  stopifnot(length(cols) == length(types))\n  df &lt;- tibble::as_tibble(setNames(vector(\"list\", length(cols)), cols))\n  for (i in seq_along(cols)) df[[i]] &lt;- do.call(types[i], list())[0]\n  df\n}\n\nRENT2   &lt;- INCOME2 &lt;- POP2 &lt;- HH2 &lt;- NULL\n\nif (requireNamespace(\"tidycensus\", quietly = TRUE)) {\n  get_acs_cbsa &lt;- function(var, years = 2009:2023, keep = CBSA_KEEP) {\n    purrr::map(years, purrr::possibly(function(yy){\n      tidycensus::get_acs(\n        geography = \"metropolitan statistical area/micropolitan statistical area\",\n        variables = var, year = yy, survey = \"acs1\", cache_table = TRUE\n      ) |&gt;\n        dplyr::transmute(CBSA = as.numeric(GEOID), NAME, year = yy, value = estimate)\n    }, NULL)) |&gt;\n      dplyr::bind_rows() |&gt;\n      dplyr::filter(CBSA %in% keep)\n  }\n\n  RENT2   &lt;- get_acs_cbsa(\"B25064_001\") |&gt; dplyr::rename(monthly_rent = value)\n  INCOME2 &lt;- get_acs_cbsa(\"B19013_001\") |&gt; dplyr::rename(household_income = value)\n  POP2    &lt;- get_acs_cbsa(\"B01003_001\") |&gt; dplyr::rename(population = value)\n  HH2     &lt;- get_acs_cbsa(\"B11001_001\") |&gt; dplyr::rename(households = value)\n}\n\n# Ensure all objects exist even if pulls failed\nif (is.null(RENT2))   RENT2   &lt;- empty_tbl(c(\"CBSA\",\"NAME\",\"year\",\"monthly_rent\"),   c(\"numeric\",\"character\",\"integer\",\"numeric\"))\nif (is.null(INCOME2)) INCOME2 &lt;- empty_tbl(c(\"CBSA\",\"NAME\",\"year\",\"household_income\"),c(\"numeric\",\"character\",\"integer\",\"numeric\"))\nif (is.null(POP2))    POP2    &lt;- empty_tbl(c(\"CBSA\",\"NAME\",\"year\",\"population\"),     c(\"numeric\",\"character\",\"integer\",\"numeric\"))\nif (is.null(HH2))     HH2     &lt;- empty_tbl(c(\"CBSA\",\"NAME\",\"year\",\"households\"),     c(\"numeric\",\"character\",\"integer\",\"numeric\"))\n\n# Save light caches\nif (.has_rows(RENT2))   readr::write_csv(RENT2,   file.path(CACHE, \"B25064_001_cbsa_2009_2023.csv\"))\nif (.has_rows(INCOME2)) readr::write_csv(INCOME2, file.path(CACHE, \"B19013_001_cbsa_2009_2023.csv\"))\nif (.has_rows(POP2))    readr::write_csv(POP2,    file.path(CACHE, \"B01003_001_cbsa_2009_2023.csv\"))\nif (.has_rows(HH2))     readr::write_csv(HH2,     file.path(CACHE, \"B11001_001_cbsa_2009_2023.csv\"))\n\ncat(\"ACS Rows — RENT2:\", nrow(RENT2), \" INCOME2:\", nrow(INCOME2), \" POP2:\", nrow(POP2), \" HH2:\", nrow(HH2), \"\\n\")\n\n\nACS Rows — RENT2: 24  INCOME2: 24  POP2: 24  HH2: 24 \n\n\n\n\n1.2 Building Permits (Census BPS), 2010–2023\n\n\nCode\nyears_perm &lt;- 2010:2023\nperm_files &lt;- file.path(CACHE, sprintf(\"msaannual_%d99.xls\", years_perm))\n\nfor (i in seq_along(years_perm)) {\n  y &lt;- years_perm[i]\n  dest &lt;- perm_files[i]\n  if (!file.exists(dest)) {\n    url &lt;- sprintf(\"https://www.census.gov/construction/bps/xls/msaannual_%d99.xls\", y)\n    try(httr2::request(url) |&gt; httr2::req_retry(max_tries = 5) |&gt; httr2::req_perform(path = dest), silent = TRUE)\n  }\n}\n\nparse_permits_xls &lt;- function(path) {\n  if (!file.exists(path)) return(NULL)\n  df &lt;- tryCatch(readxl::read_xls(path, .name_repair = \"minimal\"), error = function(e) NULL)\n  if (is.null(df) || !is.data.frame(df)) return(NULL)\n\n  nm &lt;- names(df)\n  cbsa_col  &lt;- nm[grepl(\"CBSA\", nm, ignore.case = TRUE) | grepl(\"Code\", nm, ignore.case = TRUE)]\n  if (length(cbsa_col) == 0) return(NULL)\n\n  # Try to find a plausible \"total units\" column\n  units_col &lt;- nm[grepl(\"Total\", nm, ignore.case = TRUE) & grepl(\"Unit\", nm, ignore.case = TRUE)]\n  if (length(units_col) == 0) {\n    num_cols &lt;- which(sapply(df, is.numeric))\n    if (length(num_cols) &gt; 0) units_col &lt;- nm[max(num_cols)]\n  }\n  if (length(units_col) == 0) return(NULL)\n\n  df |&gt;\n    dplyr::transmute(\n      CBSA = suppressWarnings(as.numeric(!!as.name(cbsa_col[1]))),\n      new_housing_units_permitted = suppressWarnings(as.numeric(!!as.name(units_col[1])))\n    ) |&gt;\n    dplyr::filter(!is.na(CBSA), !is.na(new_housing_units_permitted))\n}\n\nPERMITS_list &lt;- purrr::map2(\n  perm_files, years_perm,\n  ~{\n    df &lt;- parse_permits_xls(.x)\n    if (!is.null(df) && nrow(df) &gt; 0) { df$year &lt;- .y; df } else NULL\n  }\n) |&gt; purrr::compact()\n\nPERMITS &lt;- if (length(PERMITS_list) == 0) {\n  tibble::tibble(CBSA = double(), year = integer(), new_housing_units_permitted = double())\n} else {\n  dplyr::bind_rows(PERMITS_list) |&gt;\n    dplyr::select(CBSA, year, new_housing_units_permitted) |&gt;\n    dplyr::filter(CBSA %in% CBSA_KEEP)\n}\n\nif (.has_rows(PERMITS)) readr::write_csv(PERMITS, file.path(CACHE, \"housing_units_2010_2023.csv\"))\ncat(\"PERMITS Rows:\", nrow(PERMITS), \"\\n\")\n\n\nPERMITS Rows: 0 \n\n\n\n\n1.3 BLS QCEW (Employment), 2009–2023\n\n\nCode\nget_bls_qcew_annual_averages &lt;- function(start_year=2009, end_year=2023){\n  ensure_dir(CACHE)\n  fname &lt;- file.path(CACHE, sprintf(\"bls_qcew_%d_%d.csv.gz\", start_year, end_year))\n  YEARS &lt;- setdiff(seq(start_year, end_year), 2020)\n\n  if(!file.exists(fname)){\n    ALL &lt;- purrr::map(YEARS, purrr::possibly(function(yy){\n      zpath &lt;- file.path(CACHE, sprintf(\"%d_qcew_annual_singlefile.zip\", yy))\n      if(!file.exists(zpath)){\n        try(\n          httr2::request(\"https://www.bls.gov\") |&gt;\n            httr2::req_url_path(\"cew\",\"data\",\"files\", yy, \"csv\", sprintf(\"%d_annual_singlefile.zip\", yy)) |&gt;\n            httr2::req_headers(`User-Agent` = \"Mozilla/5.0\") |&gt;\n            httr2::req_retry(max_tries = 5) |&gt;\n            httr2::req_perform(zpath),\n          silent = TRUE\n        )\n      }\n      tmpdir &lt;- file.path(CACHE, sprintf(\"unz_%d\", yy))\n      if(dir.exists(tmpdir)) unlink(tmpdir, recursive = TRUE, force = TRUE)\n      dir.create(tmpdir, recursive = TRUE, showWarnings = FALSE)\n      utils::unzip(zpath, exdir = tmpdir)\n      target &lt;- list.files(tmpdir, pattern = \"annual.*singlefile.*\\\\.csv$\", full.names = TRUE, ignore.case = TRUE)\n      if(length(target)==0) target &lt;- list.files(tmpdir, pattern = \"\\\\.csv$\", full.names = TRUE)\n      if(length(target)==0) return(NULL)\n\n      readr::read_csv(target[1], show_col_types = FALSE) |&gt;\n        dplyr::mutate(YEAR = yy) |&gt;\n        dplyr::select(area_fips, industry_code, annual_avg_emplvl, total_annual_wages, YEAR) |&gt;\n        dplyr::filter(nchar(industry_code) &lt;= 5, stringr::str_starts(area_fips, \"C\")) |&gt;\n        dplyr::filter(!stringr::str_detect(industry_code, \"-\")) |&gt;\n        dplyr::transmute(\n          FIPS        = area_fips,\n          INDUSTRY    = as.integer(industry_code),\n          EMPLOYMENT  = suppressWarnings(as.numeric(annual_avg_emplvl)),\n          TOTAL_WAGES = suppressWarnings(as.numeric(total_annual_wages)),\n          YEAR        = as.integer(YEAR),\n          AVG_WAGE    = dplyr::if_else(annual_avg_emplvl &gt; 0, total_annual_wages / annual_avg_emplvl, NA_real_)\n        ) |&gt;\n        dplyr::filter(INDUSTRY != 10)\n    }, NULL)) |&gt;\n      dplyr::bind_rows()\n\n    if(is.null(ALL) || nrow(ALL)==0){\n      ALL &lt;- tibble::tibble(FIPS=character(), INDUSTRY=integer(), EMPLOYMENT=integer(),\n                            TOTAL_WAGES=double(), YEAR=integer(), AVG_WAGE=double())\n    }\n    readr::write_csv(ALL, fname)\n  }\n\n  readr::read_csv(fname, show_col_types = FALSE)\n}\n\nWAGES &lt;- get_bls_qcew_annual_averages(2009, 2023) |&gt;\n  dplyr::mutate(\n    EMPLOYMENT  = suppressWarnings(as.numeric(EMPLOYMENT)),\n    TOTAL_WAGES = suppressWarnings(as.numeric(TOTAL_WAGES)),\n    YEAR        = suppressWarnings(as.integer(YEAR)),\n    INDUSTRY    = suppressWarnings(as.integer(INDUSTRY))\n  ) |&gt;\n  dplyr::filter(!is.na(EMPLOYMENT))\n\n# Derive CBSA from BLS \"Cxxxxx\" county code → numeric × 10\nWAGES2 &lt;- WAGES |&gt;\n  dplyr::mutate(CBSA = as.double(stringr::str_remove(FIPS, \"^C\")) * 10) |&gt;\n  dplyr::filter(CBSA %in% CBSA_KEEP)\n\ncat(\"QCEW Rows — WAGES2:\", nrow(WAGES2), \"\\n\")\n\n\nQCEW Rows — WAGES2: 0 \n\n\n\n\n1.4 Combine ACS Rent & Income for Later (ACS_RI)\n\n\nCode\n.empty_acs_ri &lt;- function() {\n  tibble::tibble(\n    CBSA = numeric(),\n    NAME = character(),\n    year = integer(),\n    monthly_rent = numeric(),\n    household_income = numeric()\n  )\n}\n\nACS_RI &lt;- tryCatch({\n  RENT2 |&gt;\n    dplyr::select(CBSA, NAME, year, monthly_rent) |&gt;\n    dplyr::inner_join(\n      INCOME2 |&gt; dplyr::select(CBSA, year, household_income),\n      by = c(\"CBSA\",\"year\")\n    )\n}, error = function(e) .empty_acs_ri())\n\nneed_cols &lt;- c(\"CBSA\",\"NAME\",\"year\",\"monthly_rent\",\"household_income\")\nif (!all(need_cols %in% names(ACS_RI))) {\n  ACS_RI &lt;- .empty_acs_ri()\n}\ncat(\"ACS_RI Rows:\", nrow(ACS_RI), \"\\n\")\n\n\nACS_RI Rows: 24"
  },
  {
    "objectID": "mp02.html#task-3-policy-brief-template",
    "href": "mp02.html#task-3-policy-brief-template",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 3 — Policy Brief (Template)",
    "text": "Task 3 — Policy Brief (Template)\nScope. Compare NYC (35620) vs LA (31080) using ACS (rent, income, population, households), Census BPS permits (2010–2023), and BLS QCEW (employment).\nKey tables appear in Task 2 above (Q1–Q5).\nImplications & Recommendations. - High rent‑to‑income + muted permits/population → affordability stress; consider permitting capacity and zoning alignment. - Track a quarterly Permits Adequacy Index (permits per capita & per 5‑year growth) to flag under‑supply risk. - Use QCEW sector signals (NAICS 23/62) to gauge construction/healthcare labor capacity when planning housing expansions."
  },
  {
    "objectID": "mp02.html#visuals-initial-diagnostics-guarded",
    "href": "mp02.html#visuals-initial-diagnostics-guarded",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Visuals — Initial Diagnostics (guarded)",
    "text": "Visuals — Initial Diagnostics (guarded)\n\n\nCode\n# (1) Rent vs Income (2009)\nif (exists(\"ACS_RI\", inherits = FALSE) &&\n    .has_cols(ACS_RI, c(\"household_income\",\"monthly_rent\",\"year\"))) {\n\n  ri_2009 &lt;- ACS_RI |&gt;\n    dplyr::filter(year == 2009) |&gt;\n    dplyr::filter(!is.na(household_income), !is.na(monthly_rent))\n\n  if (.has_rows(ri_2009)) {\n    ri_2009 |&gt;\n      ggplot2::ggplot(ggplot2::aes(x = household_income, y = monthly_rent)) +\n      ggplot2::geom_point(alpha = 0.6) +\n      ggplot2::scale_x_continuous(labels = scales::label_dollar()) +\n      ggplot2::scale_y_continuous(labels = scales::label_dollar(suffix = \"/mo\")) +\n      ggplot2::labs(\n        x = \"Median Household Income (ACS)\",\n        y = \"Median Gross Rent (ACS)\",\n        title = \"Rent vs Income by CBSA (2009)\",\n        subtitle = \"ACS 1-year estimates\"\n      ) +\n      ggplot2::theme_minimal(base_size = 12)\n  } else {\n    cat(\"Note: No non-missing 2009 ACS rows for rent vs income — skipping plot.\\n\")\n  }\n} else {\n  cat(\"Note: ACS_RI is missing or lacks required columns — skipping plot.\\n\")\n}\n\n\n\n\n\n\n\n\n\nCode\n# (2) Health sector vs total employment (QCEW)\nif (exists(\"WAGES2\", inherits = FALSE) &&\n    .has_cols(WAGES2, c(\"EMPLOYMENT\",\"INDUSTRY\",\"YEAR\",\"CBSA\"))) {\n\n  WAGES2_safe &lt;- WAGES2 |&gt;\n    dplyr::mutate(\n      EMPLOYMENT = suppressWarnings(as.numeric(EMPLOYMENT)),\n      INDUSTRY   = suppressWarnings(as.integer(INDUSTRY)),\n      YEAR       = suppressWarnings(as.integer(YEAR))\n    )\n\n  health_cbsa &lt;- WAGES2_safe |&gt;\n    dplyr::filter(!is.na(YEAR), !is.na(CBSA)) |&gt;\n    dplyr::group_by(YEAR, CBSA) |&gt;\n    dplyr::summarise(\n      EMP_ALL    = sum(EMPLOYMENT, na.rm = TRUE),\n      EMP_HEALTH = sum(EMPLOYMENT * (INDUSTRY == 62L), na.rm = TRUE),\n      .groups = \"drop\"\n    )\n\n  if (.has_rows(health_cbsa) && any(!is.na(health_cbsa$YEAR))) {\n    health_cbsa |&gt;\n      ggplot2::ggplot(ggplot2::aes(x = EMP_ALL, y = EMP_HEALTH)) +\n      ggplot2::geom_point(alpha = 0.3) +\n      ggplot2::facet_wrap(~ YEAR, ncol = 4) +\n      ggplot2::scale_x_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n      ggplot2::scale_y_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n      ggplot2::labs(\n        x = \"Total Employment (QCEW)\",\n        y = \"Health & Social Services Employment (NAICS 62)\",\n        title = \"Health Sector Employment vs Overall Employment by CBSA (QCEW)\"\n      ) +\n      ggplot2::theme_minimal(base_size = 11)\n  } else {\n    cat(\"Note: QCEW health_cbsa is empty (or YEAR all NA) — skipping facet plot.\\n\")\n  }\n} else {\n  cat(\"Note: WAGES2 missing or lacks required columns — skipping QCEW plot.\\n\")\n}\n\n\nNote: QCEW health_cbsa is empty (or YEAR all NA) — skipping facet plot.\n\n\nCode\n# (3) Average household size time series\nif (exists(\"POP2\", inherits = FALSE) && exists(\"HH2\", inherits = FALSE) &&\n    .has_cols(POP2, c(\"CBSA\",\"NAME\",\"year\",\"population\")) &&\n    .has_cols(HH2,  c(\"CBSA\",\"NAME\",\"year\",\"households\"))) {\n\n  size_ts &lt;- POP2 |&gt;\n    dplyr::inner_join(HH2, dplyr::join_by(CBSA, NAME, year)) |&gt;\n    dplyr::mutate(\n      avg_household_size_est = dplyr::if_else(households &gt; 0, population / households, NA_real_)\n    ) |&gt;\n    dplyr::filter(!is.na(avg_household_size_est))\n\n  if (.has_rows(size_ts)) {\n    size_ts |&gt;\n      ggplot2::ggplot(ggplot2::aes(x = year, y = avg_household_size_est, group = CBSA)) +\n      ggplot2::geom_line(alpha = 0.15) +\n      ggplot2::labs(\n        x = NULL, y = \"Avg Household Size (rough est.)\",\n        title = \"Average Household Size by CBSA over Time\"\n      ) +\n      ggplot2::theme_minimal(base_size = 11)\n  } else {\n    cat(\"Note: Joined POP2 + HH2 has no non-missing rows — skipping time series plot.\\n\")\n  }\n\n} else {\n  cat(\"Note: POP2/HH2 missing or lacks required columns — skipping household-size plot.\\n\")\n}"
  },
  {
    "objectID": "mp02.html#task-2-joins-example-queries-answers-in-dt-tables",
    "href": "mp02.html#task-2-joins-example-queries-answers-in-dt-tables",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Task 2 — Joins & Example Queries (Answers in DT tables)",
    "text": "Task 2 — Joins & Example Queries (Answers in DT tables)\n\n\nCode\nif (!requireNamespace(\"DT\", quietly = TRUE)) install.packages(\"DT\")\nlibrary(DT)\n\n.ok &lt;- function(x) is.data.frame(x) && nrow(x) &gt; 0\nreq_ok &lt;- all(exists(\"PERMITS\", inherits = FALSE),\n              exists(\"RENT2\",   inherits = FALSE),\n              exists(\"INCOME2\", inherits = FALSE),\n              exists(\"POP2\",    inherits = FALSE))\n\nif (!req_ok) {\n  cat(\"⚠️ Task 2 skipped: missing PERMITS / RENT2 / INCOME2 / POP2.\\n\")\n} else {\n\n  # Q1: 2010–2019 leader (NYC vs LA filtered earlier)\n  cat(\"**Q1. 2010–2019 Permits Leader (NYC vs LA scope)**\\n\")\n  ans1 &lt;- PERMITS |&gt;\n    dplyr::filter(dplyr::between(year, 2010, 2019)) |&gt;\n    dplyr::group_by(CBSA) |&gt;\n    dplyr::summarise(total_permits = sum(new_housing_units_permitted, na.rm = TRUE), .groups = \"drop\") |&gt;\n    dplyr::arrange(dplyr::desc(total_permits)) |&gt;\n    dplyr::left_join(ACS_RI |&gt; dplyr::distinct(CBSA, NAME), by = \"CBSA\") |&gt;\n    dplyr::select(NAME, CBSA, total_permits)\n  if (.ok(ans1)) datatable(ans1, options = list(dom='t')) |&gt; formatRound(\"total_permits\", 0) else cat(\"No permits data for 2010–2019.\\n\")\n\n  # Q2: Peak permit year per CBSA (report both NYC & LA if present)\n  cat(\"\\n**Q2. NYC & LA Peak Permit Year**\\n\")\n  ans2 &lt;- PERMITS |&gt;\n    dplyr::group_by(CBSA) |&gt;\n    dplyr::slice_max(order_by = new_housing_units_permitted, n = 1, with_ties = FALSE) |&gt;\n    dplyr::ungroup() |&gt;\n    dplyr::left_join(ACS_RI |&gt; dplyr::distinct(CBSA, NAME), by = \"CBSA\") |&gt;\n    dplyr::select(NAME, CBSA, year, new_housing_units_permitted)\n  if (.ok(ans2)) datatable(ans2, options = list(dom='t')) else cat(\"No peak rows.\\n\")\n\n  # Q3: Highest average rent burden (2014–2023)\n  cat(\"\\n**Q3. Highest Average Rent Burden (2014–2023)**\\n\")\n  ans3 &lt;- ACS_RI |&gt;\n    dplyr::mutate(rent_to_income = (monthly_rent * 12) / household_income) |&gt;\n    dplyr::filter(dplyr::between(year, 2014, 2023)) |&gt;\n    dplyr::group_by(CBSA, NAME) |&gt;\n    dplyr::summarise(mean_RB = mean(rent_to_income, na.rm = TRUE), .groups = \"drop\") |&gt;\n    dplyr::arrange(dplyr::desc(mean_RB))\n  if (.ok(ans3)) datatable(ans3, options = list(dom='t')) |&gt; formatPercentage(\"mean_RB\", 2) else cat(\"No ACS rent/income.\\n\")\n\n  # Q4: 2009 rent–income correlation & slope (NYC & LA combined scatter stats)\n  cat(\"\\n**Q4. 2009 Rent–Income Correlation and Slope**\\n\")\n  ri_2009 &lt;- ACS_RI |&gt; dplyr::filter(year == 2009)\n  if (.ok(ri_2009)) {\n    cor_ri &lt;- suppressWarnings(stats::cor(ri_2009$household_income, ri_2009$monthly_rent, use = \"pairwise.complete.obs\"))\n    fit &lt;- tryCatch(stats::lm(monthly_rent ~ household_income, data = ri_2009), error = function(e) NULL)\n    slope &lt;- if (is.null(fit)) NA_real_ else unname(stats::coef(fit)[2])\n    datatable(data.frame(correlation_2009 = cor_ri, slope_dollars_per_income = slope), options = list(dom='t')) |&gt;\n      formatRound(c(\"correlation_2009\",\"slope_dollars_per_income\"), 4)\n  } else cat(\"No 2009 ACS rows.\\n\")\n\n  # Q5: Composite housing growth (2014–2023)\n  cat(\"\\n**Q5. Composite Housing Growth (2014–2023)**\\n\")\n  perm_pop &lt;- PERMITS |&gt;\n    dplyr::inner_join(POP2, dplyr::join_by(CBSA, year)) |&gt;\n    dplyr::select(CBSA, year, new_housing_units_permitted, population) |&gt;\n    dplyr::group_by(CBSA) |&gt;\n    dplyr::arrange(year, .by_group = TRUE) |&gt;\n    dplyr::mutate(pop_5y_ago = dplyr::lag(population, 5),\n                  pop_growth_5y = population - pop_5y_ago) |&gt;\n    dplyr::ungroup()\n\n  if (.ok(perm_pop)) {\n    hg_instant &lt;- perm_pop |&gt;\n      dplyr::mutate(inst = new_housing_units_permitted / pmax(population, 1)) |&gt;\n      dplyr::filter(dplyr::between(year, 2014, 2023)) |&gt;\n      dplyr::group_by(year) |&gt;\n      dplyr::mutate(inst_0100 = 100 * (inst - min(inst, na.rm=TRUE)) / (max(inst, na.rm=TRUE) - min(inst, na.rm=TRUE))) |&gt;\n      dplyr::ungroup()\n\n    hg_rate &lt;- perm_pop |&gt;\n      dplyr::mutate(rate = new_housing_units_permitted / pmax(pop_growth_5y, 1)) |&gt;\n      dplyr::filter(dplyr::between(year, 2014, 2023)) |&gt;\n      dplyr::group_by(year) |&gt;\n      dplyr::mutate(rate_0100 = 100 * (rate - min(rate, na.rm=TRUE)) / (max(rate, na.rm=TRUE) - min(rate, na.rm=TRUE))) |&gt;\n      dplyr::ungroup()\n\n    HG &lt;- hg_instant |&gt;\n      dplyr::select(CBSA, year, inst_0100) |&gt;\n      dplyr::inner_join(hg_rate |&gt; dplyr::select(CBSA, year, rate_0100), by = c(\"CBSA\",\"year\")) |&gt;\n      dplyr::mutate(hg_composite = 0.5*inst_0100 + 0.5*rate_0100)\n\n    ans5 &lt;- HG |&gt;\n      dplyr::group_by(CBSA) |&gt;\n      dplyr::summarise(mean_hg_2014_2023 = mean(hg_composite, na.rm = TRUE), .groups = \"drop\") |&gt;\n      dplyr::arrange(dplyr::desc(mean_hg_2014_2023)) |&gt;\n      dplyr::left_join(ACS_RI |&gt; dplyr::distinct(CBSA, NAME), by = \"CBSA\") |&gt;\n      dplyr::select(NAME, CBSA, mean_hg_2014_2023)\n\n    if (.ok(ans5)) datatable(ans5, options = list(dom='t')) |&gt; formatRound(\"mean_hg_2014_2023\", 2) else cat(\"No composite rows.\\n\")\n  } else {\n    cat(\"PERMITS + POP join empty.\\n\")\n  }\n}\n\n\n**Q1. 2010–2019 Permits Leader (NYC vs LA scope)**\nNo permits data for 2010–2019.\n\n**Q2. NYC & LA Peak Permit Year**\nNo peak rows.\n\n**Q3. Highest Average Rent Burden (2014–2023)**\n\n**Q4. 2009 Rent–Income Correlation and Slope**\n\n**Q5. Composite Housing Growth (2014–2023)**\nPERMITS + POP join empty."
  },
  {
    "objectID": "mp02.html#visuals-quick-diagnostics-guarded",
    "href": "mp02.html#visuals-quick-diagnostics-guarded",
    "title": "Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Visuals — Quick Diagnostics (Guarded)",
    "text": "Visuals — Quick Diagnostics (Guarded)\n\n\nCode\n# 1) Rent vs Income (2009)\nif (.has_cols(ACS_RI, c(\"household_income\",\"monthly_rent\",\"year\"))) {\n  ri_2009 &lt;- ACS_RI |&gt; dplyr::filter(year == 2009) |&gt; dplyr::filter(!is.na(household_income), !is.na(monthly_rent))\n  if (.has_rows(ri_2009)) {\n    ri_2009 |&gt;\n      ggplot(aes(household_income, monthly_rent, color = factor(CBSA))) +\n      geom_point(alpha = 0.7) +\n      scale_x_continuous(labels = scales::label_dollar()) +\n      scale_y_continuous(labels = scales::label_dollar(suffix = \"/mo\")) +\n      labs(x = \"Median Household Income (ACS)\",\n           y = \"Median Gross Rent (ACS)\",\n           title = \"Rent vs Income (2009): NYC vs LA\",\n           color = \"CBSA\") +\n      theme_minimal(base_size = 12)\n  } else cat(\"Note: No non-missing 2009 ACS rows — skipping plot.\\n\")\n} else cat(\"Note: ACS_RI missing required columns — skipping plot.\\n\")\n\n\n\n\n\n\n\n\n\nCode\n# 2) Health sector vs total employment (QCEW)\nif (.has_cols(WAGES2, c(\"EMPLOYMENT\",\"INDUSTRY\",\"YEAR\",\"CBSA\"))) {\n  WAGES2_safe &lt;- WAGES2 |&gt;\n    mutate(EMPLOYMENT = suppressWarnings(as.numeric(EMPLOYMENT)),\n           INDUSTRY   = suppressWarnings(as.integer(INDUSTRY)),\n           YEAR       = suppressWarnings(as.integer(YEAR)))\n  health_cbsa &lt;- WAGES2_safe |&gt;\n    group_by(YEAR, CBSA) |&gt;\n    summarise(EMP_ALL = sum(EMPLOYMENT, na.rm=TRUE),\n              EMP_HEALTH = sum(EMPLOYMENT * (INDUSTRY == 62L), na.rm=TRUE), .groups=\"drop\")\n  if (.has_rows(health_cbsa)) {\n    health_cbsa |&gt;\n      ggplot(aes(EMP_ALL, EMP_HEALTH, color = factor(CBSA))) +\n      geom_point(alpha = 0.5) +\n      facet_wrap(~ YEAR, ncol = 4) +\n      scale_x_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n      scale_y_continuous(labels = scales::label_number(scale = 1e-3, suffix = \"K\")) +\n      labs(x=\"Total Employment (QCEW)\", y=\"Health & Social Services Employment (NAICS 62)\",\n           title=\"Health Sector vs Overall Employment — NYC vs LA\", color=\"CBSA\") +\n      theme_minimal(base_size = 11)\n  } else cat(\"Note: health_cbsa empty — skipping.\\n\")\n} else cat(\"Note: WAGES2 missing required columns — skipping.\\n\")\n\n\nNote: health_cbsa empty — skipping."
  },
  {
    "objectID": "mp02.html#appendix-reproducibility-tips",
    "href": "mp02.html#appendix-reproducibility-tips",
    "title": "STA 9750 Mini‑Project #02: Making Backyards Affordable for All",
    "section": "Appendix — Reproducibility Tips",
    "text": "Appendix — Reproducibility Tips\n\nIf you hit Census API throttling, consider setting a permanent key with:\ncensus_api_key(\"YOUR_KEY\", install = TRUE); readRenviron(\"~/.Renviron\")\nFirst runs of BLS QCEW downloads are large/slow. If a zip looks corrupted, delete it from data/mp02/ and rerun.\nTo publish on GitHub Pages as per course convention, render to docs/mp02.html (all lowercase). ```"
  },
  {
    "objectID": "mp03.html",
    "href": "mp03.html",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "",
    "text": "# Global chunk options\nknitr::opts_chunk$set(\n  echo = TRUE,\n  warning = FALSE,\n  message = FALSE,\n  fig.width = 8,\n  fig.height = 6\n)\n\n# Packages\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(httr2)\nlibrary(purrr)\n\n# Data directory\ndir.create(\"data/mp03\", showWarnings = FALSE, recursive = TRUE)"
  },
  {
    "objectID": "mp03.html#city-council-districts",
    "href": "mp03.html#city-council-districts",
    "title": "Mini-Project #03: Visualizing and Maintaining the Green Canopy of NYC",
    "section": "1.1 City Council Districts",
    "text": "1.1 City Council Districts\n\ndownload_council_districts &lt;- function(\n  dest_dir = \"data/mp03\",\n  zip_url  = \"https://data.cityofnewyork.us/api/geospatial/mkqi-d8x3?method=export&format=Shapefile\",\n  zip_name = \"nyc_council_districts_open_data.zip\"\n) {\n  dir.create(dest_dir, showWarnings = FALSE, recursive = TRUE)\n  zip_path &lt;- file.path(dest_dir, zip_name)\n\n  if (!file.exists(zip_path)) {\n    resp &lt;- httr2::request(zip_url) |&gt; httr2::req_perform()\n    writeBin(httr2::resp_body_raw(resp), zip_path)\n  }\n\n  shp_files &lt;- list.files(dest_dir, full.names = TRUE)\n  if (!any(tools::file_ext(shp_files) == \"shp\")) {\n    unzip(zip_path, exdir = dest_dir)\n    shp_files &lt;- list.files(dest_dir, full.names = TRUE)\n  }\n\n  shp_file &lt;- shp_files[tools::file_ext(shp_files) == \"shp\"][1]\n  nycc_raw &lt;- sf::st_read(shp_file, quiet = TRUE)\n\n  possible_names &lt;- c(\"coun_dist\",\"coundist\",\"council\",\"council_d\",\"councildis\",\"council_district\")\n  existing &lt;- intersect(possible_names, names(nycc_raw))\n  names(nycc_raw)[names(nycc_raw) == existing[1]] &lt;- \"COUNDIST\"\n\n  nycc_raw &lt;- sf::st_transform(nycc_raw, \"WGS84\")\n  nycc_raw$area_m2 &lt;- as.numeric(sf::st_area(nycc_raw))\n  nycc_raw\n}\n\nnyc_council &lt;- download_council_districts()"
  },
  {
    "objectID": "mp03.html#tree-points",
    "href": "mp03.html#tree-points",
    "title": "Mini-Project #03: Visualizing and Maintaining the Green Canopy of NYC",
    "section": "1.2 Tree Points",
    "text": "1.2 Tree Points\n\ndownload_tree_points &lt;- function(\n  dest_dir  = \"data/mp03\",\n  base_url  = \"https://data.cityofnewyork.us/resource/hn5i-inap.geojson\",\n  limit     = 10000,\n  max_files = 3\n){\n  dir.create(dest_dir, showWarnings = FALSE, recursive = TRUE)\n  all_files &lt;- character()\n  offset &lt;- 0L\n  file_idx &lt;- 0L\n\n  repeat {\n    file_idx &lt;- file_idx + 1L\n    file_path &lt;- file.path(dest_dir, sprintf(\"treepoints_%06d.geojson\", offset))\n\n    if (!file.exists(file_path)) {\n      resp &lt;- httr2::request(base_url) |&gt;\n        httr2::req_url_query(\"$limit\"=limit, \"$offset\"=offset) |&gt;\n        httr2::req_perform()\n      writeLines(httr2::resp_body_string(resp), file_path)\n    }\n\n    all_files &lt;- c(all_files, file_path)\n    page &lt;- sf::st_read(file_path, quiet=TRUE)\n\n    if (nrow(page) &lt; limit || file_idx &gt;= max_files) break\n    offset &lt;- offset + limit\n  }\n\n  trees &lt;- purrr::map(all_files, ~ sf::st_read(.x, quiet=TRUE)) |&gt; bind_rows()\n  trees |&gt; sf::st_transform(\"WGS84\")\n}\n\nnyc_trees &lt;- download_tree_points()"
  },
  {
    "objectID": "mp03.html#district-level-summary-table",
    "href": "mp03.html#district-level-summary-table",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.1 4.1 District-Level Summary Table",
    "text": "4.1 4.1 District-Level Summary Table\n\ncomparison_summary &lt;- trees_with_districts |&gt;\n  sf::st_drop_geometry() |&gt;\n  dplyr::group_by(COUNDIST) |&gt;\n  dplyr::summarise(\n    n_trees   = dplyr::n(),\n    n_dead    = sum(tolower(tpcondition) == \"dead\", na.rm = TRUE),\n    frac_dead = n_dead / n_trees,\n    area_m2   = dplyr::first(area_m2),\n    density   = n_trees / area_m2,\n    .groups   = \"drop\"\n  )\n\ncomparison_summary\n\n# A tibble: 51 × 6\n   COUNDIST n_trees n_dead frac_dead   area_m2   density\n      &lt;dbl&gt;   &lt;int&gt;  &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1        1     173     21     0.121 14757220. 0.0000117\n 2        2     232     40     0.172  5295436. 0.0000438\n 3        3     319     48     0.150 10300124. 0.0000310\n 4        4     316     54     0.171  8389862. 0.0000377\n 5        5     189     22     0.116  5937286. 0.0000318\n 6        6     198     34     0.172  9870304. 0.0000201\n 7        7     183     36     0.197  8086525. 0.0000226\n 8        8     138     40     0.290 12051724. 0.0000115\n 9        9     183     31     0.169  5733623. 0.0000319\n10       10     131     24     0.183 11728790. 0.0000112\n# ℹ 41 more rows"
  },
  {
    "objectID": "mp03.html#which-council-district-has-the-most-trees",
    "href": "mp03.html#which-council-district-has-the-most-trees",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.2 4.2 Which council district has the most trees?",
    "text": "4.2 4.2 Which council district has the most trees?\n\nmost_trees &lt;- comparison_summary |&gt;\n  arrange(desc(n_trees)) |&gt;\n  slice(1)\n\nmost_trees\n\n# A tibble: 1 × 6\n  COUNDIST n_trees n_dead frac_dead    area_m2   density\n     &lt;dbl&gt;   &lt;int&gt;  &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n1       50    3332    573     0.172 105620412. 0.0000315\n\n\nAnswer (Q1): The council district with the most trees is District\n50, with 3332 trees in our sample."
  },
  {
    "objectID": "mp03.html#which-council-district-has-the-highest-density-of-trees",
    "href": "mp03.html#which-council-district-has-the-highest-density-of-trees",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.3 4.3 Which council district has the highest density of trees?",
    "text": "4.3 4.3 Which council district has the highest density of trees?\n\nhighest_density &lt;- comparison_summary |&gt;\n  arrange(desc(density)) |&gt;\n  slice(1)\n\nhighest_density\n\n# A tibble: 1 × 6\n  COUNDIST n_trees n_dead frac_dead  area_m2   density\n     &lt;dbl&gt;   &lt;int&gt;  &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1       35     494     80     0.162 7371398. 0.0000670\n\n\nAnswer (Q2): The highest tree density is in District\n35, with a density of about\n6.7^{-5} trees per square meter (based on the district polygon area)."
  },
  {
    "objectID": "mp03.html#which-district-has-the-highest-fraction-of-dead-trees",
    "href": "mp03.html#which-district-has-the-highest-fraction-of-dead-trees",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.4 4.4 Which district has the highest fraction of dead trees?",
    "text": "4.4 4.4 Which district has the highest fraction of dead trees?\n\nhighest_dead_fraction &lt;- comparison_summary |&gt;\n  arrange(desc(frac_dead)) |&gt;\n  slice(1)\n\nhighest_dead_fraction\n\n# A tibble: 1 × 6\n  COUNDIST n_trees n_dead frac_dead  area_m2   density\n     &lt;dbl&gt;   &lt;int&gt;  &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1       16      80     48       0.6 5778852. 0.0000138\n\n\nAnswer (Q3): The highest fraction of dead trees is in District\n16, where about\n0.6 of trees are recorded as dead."
  },
  {
    "objectID": "mp03.html#what-is-the-most-common-tree-species-in-manhattan",
    "href": "mp03.html#what-is-the-most-common-tree-species-in-manhattan",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.5 4.5 What is the most common tree species in Manhattan?",
    "text": "4.5 4.5 What is the most common tree species in Manhattan?\nFirst, create a borough column from council district numbers:\n\ntrees_with_boro &lt;- trees_with_districts |&gt;\n  mutate(\n    Borough = case_when(\n      COUNDIST &gt;= 1  & COUNDIST &lt;= 10 ~ \"Manhattan\",\n      COUNDIST &gt;= 11 & COUNDIST &lt;= 18 ~ \"Bronx\",\n      COUNDIST &gt;= 19 & COUNDIST &lt;= 32 ~ \"Queens\",\n      COUNDIST &gt;= 33 & COUNDIST &lt;= 48 ~ \"Brooklyn\",\n      COUNDIST &gt;= 49 & COUNDIST &lt;= 51 ~ \"Staten Island\",\n      TRUE ~ NA_character_\n    )\n  )\n\n# Determine which column to use for species\nspecies_col &lt;- if (\"spc_common\" %in% names(trees_with_boro)) {\n  \"spc_common\"\n} else if (\"genusspecies\" %in% names(trees_with_boro)) {\n  \"genusspecies\"\n} else {\n  NA_character_\n}\n\nspecies_col\n\n[1] \"genusspecies\"\n\n\n\nif (is.na(species_col)) {\n  manhattan_top_species &lt;- tibble(\n    note = \"No species column available in this dataset.\"\n  )\n} else {\n  manhattan_top_species &lt;- trees_with_boro |&gt;\n    filter(Borough == \"Manhattan\") |&gt;\n    sf::st_drop_geometry() |&gt;\n    count(.data[[species_col]], sort = TRUE) |&gt;\n    slice(1)\n}\n\nmanhattan_top_species\n\n                                                genusspecies   n\n1 Gleditsia triacanthos var. inermis - Thornless honeylocust 399\n\n\nAnswer (Q4): In Manhattan, the most common tree species (by count in our joined data) is:\nGleditsia triacanthos var. inermis - Thornless honeylocust."
  },
  {
    "objectID": "mp03.html#what-is-the-species-of-the-tree-closest-to-baruchs-campus",
    "href": "mp03.html#what-is-the-species-of-the-tree-closest-to-baruchs-campus",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.6 4.6 What is the species of the tree closest to Baruch’s campus?",
    "text": "4.6 4.6 What is the species of the tree closest to Baruch’s campus?\n\nnew_st_point &lt;- function(lat, lon){\n  sf::st_sfc(sf::st_point(c(lon, lat))) |&gt;\n    sf::st_set_crs(\"WGS84\")\n}\n\n# Approximate coordinates for Baruch College (Newman Vertical Campus)\nbaruch_point &lt;- new_st_point(lat = 40.7403, lon = -73.9837)\n\nclosest_tree &lt;- trees_with_districts |&gt;\n  mutate(distance_m = as.numeric(sf::st_distance(geometry, baruch_point))) |&gt;\n  arrange(distance_m) |&gt;\n  slice(1) |&gt;\n  sf::st_drop_geometry()\n\nclosest_tree\n\n  tpcondition stumpdiameter riskratingdate riskrating objectid\n1        Good          &lt;NA&gt;           &lt;NA&gt;       &lt;NA&gt;   386684\n                              globalid tpstructure\n1 8998DD59-D798-4200-8AFC-39ADD925F620     Retired\n                 plantingspaceglobalid         createddate dbh planteddate\n1 78FDD794-694E-429F-9C0D-1444792CC67F 2015-08-11 14:43:00   9        &lt;NA&gt;\n          updateddate\n1 2018-08-16 18:28:38\n                                                genusspecies COUNDIST\n1 Gleditsia triacanthos var. inermis - Thornless honeylocust        2\n  shape_leng shape_area area_m2 distance_m\n1   43018.81   57068955 5295436   109.4842\n\n\nAnswer (Q5): The tree closest to Baruch’s campus is of species\nGleditsia triacanthos var. inermis - Thornless honeylocust,\nand is approximately 109.5 meters from Baruch."
  },
  {
    "objectID": "mp03.html#city-council-district-boundaries-nyc-open-data",
    "href": "mp03.html#city-council-district-boundaries-nyc-open-data",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "1.1 1.1 City Council District Boundaries (NYC Open Data)",
    "text": "1.1 1.1 City Council District Boundaries (NYC Open Data)\n\ndownload_council_districts &lt;- function(\n  dest_dir = \"data/mp03\",\n  zip_url  = \"https://data.cityofnewyork.us/api/geospatial/mkqi-d8x3?method=export&format=Shapefile\",\n  zip_name = \"nyc_council_districts_open_data.zip\"\n) {\n  dir.create(dest_dir, showWarnings = FALSE, recursive = TRUE)\n  zip_path &lt;- file.path(dest_dir, zip_name)\n\n  # Download shapefile zip from NYC Open Data if not already present\n  if (!file.exists(zip_path)) {\n    message(\"Downloading City Council shapefile zip from NYC Open Data ...\")\n    resp &lt;- httr2::request(zip_url) |&gt;\n      httr2::req_perform()\n    writeBin(httr2::resp_body_raw(resp), zip_path)\n  } else {\n    message(\"Zip already exists, skipping download.\")\n  }\n\n  # List files and check for any .shp\n  all_files &lt;- list.files(dest_dir, full.names = TRUE)\n  has_shp   &lt;- any(tools::file_ext(all_files) == \"shp\")\n\n  # If no shapefile yet, unzip\n  if (!has_shp) {\n    message(\"Unzipping shapefile ...\")\n    unzip(zip_path, exdir = dest_dir)\n    all_files &lt;- list.files(dest_dir, full.names = TRUE)\n  }\n\n  shp_files &lt;- all_files[tools::file_ext(all_files) == \"shp\"]\n  if (length(shp_files) == 0) {\n    stop(\"Could not find .shp file in \", dest_dir)\n  }\n\n  shp_file &lt;- shp_files[1]\n  nycc_raw &lt;- sf::st_read(shp_file, quiet = TRUE)\n\n  # Find the council district column and rename it to COUNDIST\n  nm       &lt;- names(nycc_raw)\n  nm_lower &lt;- tolower(nm)\n  possible_lower &lt;- c(\"coun_dist\", \"coundist\", \"council\", \"council_d\",\n                      \"councildis\", \"council_district\")\n  idx &lt;- which(nm_lower %in% possible_lower)\n\n  if (length(idx) == 0) {\n    stop(\"Could not find council district column. Columns are: \",\n         paste(nm, collapse = \", \"))\n  }\n\n  names(nycc_raw)[idx[1]] &lt;- \"COUNDIST\"\n\n  # Transform to WGS84\n  nycc_wgs84 &lt;- sf::st_transform(nycc_raw, \"WGS84\")\n\n  # Compute district area in square meters for density calculations\n  nycc_wgs84$area_m2 &lt;- as.numeric(sf::st_area(nycc_wgs84))\n\n  nycc_wgs84\n}\n\nnyc_council &lt;- download_council_districts()\nnyc_council\n\nSimple feature collection with 51 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -74.25875 ymin: 40.47737 xmax: -73.70001 ymax: 40.91766\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   COUNDIST shape_leng shape_area                       geometry   area_m2\n1        42  117530.81  411895232 MULTIPOLYGON (((-73.86078 4...  38220229\n2        45   56967.63  117904762 MULTIPOLYGON (((-73.92347 4...  10940516\n3        20   61223.01  144833269 MULTIPOLYGON (((-73.82433 4...  13439032\n4        21   70355.16  150651760 MULTIPOLYGON (((-73.87125 4...  13978895\n5        22   86774.78  186235161 MULTIPOLYGON (((-73.87226 4...  17280622\n6        19  117797.09  479560205 MULTIPOLYGON (((-73.77896 4...  44497982\n7        30   74047.83  168917281 MULTIPOLYGON (((-73.87266 4...  15673850\n8        29   61867.75  127849353 MULTIPOLYGON (((-73.84701 4...  11863165\n9        51  180520.74 1326829378 MULTIPOLYGON (((-74.1629 40... 123118846\n10       23   84551.73  311520683 MULTIPOLYGON (((-73.72021 4...  28905965"
  },
  {
    "objectID": "mp03.html#forestry-tree-points-nyc-open-data-api",
    "href": "mp03.html#forestry-tree-points-nyc-open-data-api",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "1.2 1.2 Forestry Tree Points (NYC Open Data API)",
    "text": "1.2 1.2 Forestry Tree Points (NYC Open Data API)\n\ndownload_tree_points &lt;- function(\n  dest_dir   = \"data/mp03\",\n  base_url   = \"https://data.cityofnewyork.us/resource/hn5i-inap.geojson\",\n  limit      = 10000,\n  max_pages  = 2   # For development; set to Inf for full data when ready\n) {\n  dir.create(dest_dir, showWarnings = FALSE, recursive = TRUE)\n\n  all_files &lt;- character()\n  offset    &lt;- 0L\n  page_id   &lt;- 0L\n\n  repeat {\n    page_id  &lt;- page_id + 1L\n    file_path &lt;- file.path(dest_dir, sprintf(\"treepoints_%06d.geojson\", offset))\n\n    if (!file.exists(file_path)) {\n      message(\"Downloading tree page with offset = \", offset)\n      resp &lt;- httr2::request(base_url) |&gt;\n        httr2::req_url_query(\n          \"$limit\"  = limit,\n          \"$offset\" = offset\n        ) |&gt;\n        httr2::req_perform()\n      writeLines(httr2::resp_body_string(resp), file_path)\n    } else {\n      message(\"File already exists for offset = \", offset, \"; skipping download.\")\n    }\n\n    all_files &lt;- c(all_files, file_path)\n\n    # Quick check of how many rows in this page\n    page &lt;- sf::st_read(file_path, quiet = TRUE)\n    n_obs &lt;- nrow(page)\n    message(\"Rows in this page: \", n_obs)\n\n    # Stopping conditions:\n    if (n_obs &lt; limit || page_id &gt;= max_pages) {\n      message(\"Stopping pagination.\")\n      break\n    }\n\n    offset &lt;- offset + limit\n  }\n\n  # Read each page, harmonize planteddate type, then bind rows\n  tree_list &lt;- purrr::map(all_files, function(f) {\n    x &lt;- sf::st_read(f, quiet = TRUE)\n    if (\"planteddate\" %in% names(x)) {\n      x$planteddate &lt;- as.character(x$planteddate)\n    }\n    x\n  })\n\n  trees &lt;- dplyr::bind_rows(tree_list)\n\n  sf::st_transform(trees, \"WGS84\")\n}\n\nnyc_trees &lt;- download_tree_points()\nnyc_trees\n\nSimple feature collection with 20000 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -74.25448 ymin: 40.49891 xmax: -73.70139 ymax: 40.91108\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   tpcondition stumpdiameter      riskratingdate riskrating objectid\n1    Excellent          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    86823\n2         Good          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    87623\n3         Poor          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    88023\n4         Fair          &lt;NA&gt; 2024-06-28 12:41:55          6    88823\n5         Dead          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    88824\n6         Fair          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    88825\n7     Critical          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89223\n8         Dead          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89225\n9      Unknown          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89625\n10        Fair          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89626\n                               globalid tpstructure\n1  2B457A4C-E0E4-4E17-81C4-A5449F51C804        Full\n2  37195E1A-A7EE-4AA4-8389-19A0ED5C46F7     Retired\n3  6BA8E72B-1901-4EF3-ABFF-D11680AB4A9B     Retired\n4  79A5DBAF-F305-4DA1-A4B1-7A8C8D085435        Full\n5  182F6647-D9C1-4A45-ADA0-9ADEFD1ECC60     Retired\n6  394AEC59-B91C-45AD-93FB-2996B0C09747     Retired\n7  8717EC83-F165-495A-A1AA-1064173A681F     Retired\n8  FD617E56-130C-4E43-A76D-3AF989E37A2F     Retired\n9  380AB840-F0E9-4B14-A4D6-A99B8861065E     Retired\n10 8A487A6B-146A-4DE4-9AEE-835492B1E348     Retired\n                  plantingspaceglobalid         createddate dbh planteddate\n1  E814CD37-9F53-4D79-AF86-3B454F9D29B9 2015-02-28 05:00:00  20        &lt;NA&gt;\n2  A644AB79-A3CB-4F7F-923B-F308E615CCD4 2015-03-03 05:00:00  10        &lt;NA&gt;\n3  21431016-EDB8-4A0B-B122-673125800C87 2015-03-03 05:00:00  24        &lt;NA&gt;\n4  96FB6C55-612F-466D-9449-85A3CD2178E1 2015-03-04 05:00:00  10        &lt;NA&gt;\n5  4796B64F-906C-4345-A4E9-5CD6133642F8 2015-03-04 05:00:00  10        &lt;NA&gt;\n6  F31930BA-47FD-4D9F-B8A2-7A4FA4707D16 2015-03-04 05:00:00  19        &lt;NA&gt;\n7  ED1D6BF0-C0E7-49BB-9A1A-85CBF8558ACD 2015-03-04 05:00:00  12        &lt;NA&gt;\n8  6AC474F7-0D16-43EC-A1F9-8C9B6C14F434 2015-03-04 05:00:00   8        &lt;NA&gt;\n9  8E628B41-0A1D-4948-AAE3-F0B3A2A8AFE8 2015-03-04 05:00:00   6        &lt;NA&gt;\n10 C6526419-CD64-4D8D-9288-C7967124B9B4 2015-03-04 05:00:00  15        &lt;NA&gt;\n           updateddate\n1  2016-10-20 17:43:53\n2  2019-09-18 13:12:55\n3  2018-03-27 14:00:42\n4  2024-06-28 12:41:55\n5  2016-10-24 02:50:43\n6  2017-04-12 09:35:50\n7  2020-01-08 16:27:00\n8  2017-09-11 08:51:17\n9  2016-12-28 12:18:15\n10 2023-12-11 18:01:07\n                                                 genusspecies\n1                                   Acer nigrum - black maple\n2                          Fraxinus pennsylvanica - Green ash\n3                             Acer platanoides - Norway maple\n4                             Pyrus calleryana - Callery pear\n5  Gleditsia triacanthos var. inermis - Thornless honeylocust\n6                              Fraxinus americana - white ash\n7                          Zelkova serrata - Japanese zelkova\n8                             Acer platanoides - Norway maple\n9                           Tilia cordata - littleleaf linden\n10                                    Abies alba - silver fir\n                     geometry\n1  POINT (-73.81657 40.71629)\n2  POINT (-73.93848 40.81299)\n3  POINT (-73.83244 40.88763)\n4  POINT (-74.20904 40.51958)\n5  POINT (-73.98032 40.74291)\n6   POINT (-73.73589 40.7359)\n7  POINT (-73.96597 40.79516)\n8  POINT (-74.13088 40.60673)\n9  POINT (-73.96474 40.80428)\n10 POINT (-73.85288 40.67823)"
  },
  {
    "objectID": "mp03.html#join-tree-points-with-council-districts",
    "href": "mp03.html#join-tree-points-with-council-districts",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "1.3 1.3 Join Tree Points with Council Districts",
    "text": "1.3 1.3 Join Tree Points with Council Districts\n\ntrees_with_districts &lt;- sf::st_join(nyc_trees, nyc_council, join = sf::st_within)\n\n# Ensure tpcondition exists so later code does not fail\nif (!\"tpcondition\" %in% names(trees_with_districts)) {\n  trees_with_districts$tpcondition &lt;- NA_character_\n}\n\ntrees_with_districts\n\nSimple feature collection with 20000 features and 17 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -74.25448 ymin: 40.49891 xmax: -73.70139 ymax: 40.91108\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   tpcondition stumpdiameter      riskratingdate riskrating objectid\n1    Excellent          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    86823\n2         Good          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    87623\n3         Poor          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    88023\n4         Fair          &lt;NA&gt; 2024-06-28 12:41:55          6    88823\n5         Dead          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    88824\n6         Fair          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    88825\n7     Critical          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89223\n8         Dead          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89225\n9      Unknown          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89625\n10        Fair          &lt;NA&gt;                &lt;NA&gt;       &lt;NA&gt;    89626\n                               globalid tpstructure\n1  2B457A4C-E0E4-4E17-81C4-A5449F51C804        Full\n2  37195E1A-A7EE-4AA4-8389-19A0ED5C46F7     Retired\n3  6BA8E72B-1901-4EF3-ABFF-D11680AB4A9B     Retired\n4  79A5DBAF-F305-4DA1-A4B1-7A8C8D085435        Full\n5  182F6647-D9C1-4A45-ADA0-9ADEFD1ECC60     Retired\n6  394AEC59-B91C-45AD-93FB-2996B0C09747     Retired\n7  8717EC83-F165-495A-A1AA-1064173A681F     Retired\n8  FD617E56-130C-4E43-A76D-3AF989E37A2F     Retired\n9  380AB840-F0E9-4B14-A4D6-A99B8861065E     Retired\n10 8A487A6B-146A-4DE4-9AEE-835492B1E348     Retired\n                  plantingspaceglobalid         createddate dbh planteddate\n1  E814CD37-9F53-4D79-AF86-3B454F9D29B9 2015-02-28 05:00:00  20        &lt;NA&gt;\n2  A644AB79-A3CB-4F7F-923B-F308E615CCD4 2015-03-03 05:00:00  10        &lt;NA&gt;\n3  21431016-EDB8-4A0B-B122-673125800C87 2015-03-03 05:00:00  24        &lt;NA&gt;\n4  96FB6C55-612F-466D-9449-85A3CD2178E1 2015-03-04 05:00:00  10        &lt;NA&gt;\n5  4796B64F-906C-4345-A4E9-5CD6133642F8 2015-03-04 05:00:00  10        &lt;NA&gt;\n6  F31930BA-47FD-4D9F-B8A2-7A4FA4707D16 2015-03-04 05:00:00  19        &lt;NA&gt;\n7  ED1D6BF0-C0E7-49BB-9A1A-85CBF8558ACD 2015-03-04 05:00:00  12        &lt;NA&gt;\n8  6AC474F7-0D16-43EC-A1F9-8C9B6C14F434 2015-03-04 05:00:00   8        &lt;NA&gt;\n9  8E628B41-0A1D-4948-AAE3-F0B3A2A8AFE8 2015-03-04 05:00:00   6        &lt;NA&gt;\n10 C6526419-CD64-4D8D-9288-C7967124B9B4 2015-03-04 05:00:00  15        &lt;NA&gt;\n           updateddate\n1  2016-10-20 17:43:53\n2  2019-09-18 13:12:55\n3  2018-03-27 14:00:42\n4  2024-06-28 12:41:55\n5  2016-10-24 02:50:43\n6  2017-04-12 09:35:50\n7  2020-01-08 16:27:00\n8  2017-09-11 08:51:17\n9  2016-12-28 12:18:15\n10 2023-12-11 18:01:07\n                                                 genusspecies COUNDIST\n1                                   Acer nigrum - black maple       24\n2                          Fraxinus pennsylvanica - Green ash        9\n3                             Acer platanoides - Norway maple       12\n4                             Pyrus calleryana - Callery pear       51\n5  Gleditsia triacanthos var. inermis - Thornless honeylocust        2\n6                              Fraxinus americana - white ash       23\n7                          Zelkova serrata - Japanese zelkova        7\n8                             Acer platanoides - Norway maple       49\n9                           Tilia cordata - littleleaf linden        7\n10                                    Abies alba - silver fir       32\n   shape_leng shape_area   area_m2                   geometry\n1    76779.51  186824791  17335488 POINT (-73.81657 40.71629)\n2    46709.56   61792463   5733623 POINT (-73.93848 40.81299)\n3    58158.18  131040795  12158897 POINT (-73.83244 40.88763)\n4   180520.74 1326829378 123118846 POINT (-74.20904 40.51958)\n5    43018.81   57068955   5295436 POINT (-73.98032 40.74291)\n6    84551.73  311520683  28905965  POINT (-73.73589 40.7359)\n7    53865.83   87149990   8086525 POINT (-73.96597 40.79516)\n8   130453.01  442729636  41081370 POINT (-74.13088 40.60673)\n9    53865.83   87149990   8086525 POINT (-73.96474 40.80428)\n10  327361.62 1773673447 164581989 POINT (-73.85288 40.67823)"
  },
  {
    "objectID": "mp03.html#most-common-tree-species-in-manhattan",
    "href": "mp03.html#most-common-tree-species-in-manhattan",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.5 4.5 Most Common Tree Species in Manhattan",
    "text": "4.5 4.5 Most Common Tree Species in Manhattan\n\ntrees_with_boro &lt;- trees_with_districts |&gt;\n  mutate(\n    Borough = case_when(\n      COUNDIST &gt;= 1  & COUNDIST &lt;= 10 ~ \"Manhattan\",\n      COUNDIST &gt;= 11 & COUNDIST &lt;= 18 ~ \"Bronx\",\n      COUNDIST &gt;= 19 & COUNDIST &lt;= 32 ~ \"Queens\",\n      COUNDIST &gt;= 33 & COUNDIST &lt;= 48 ~ \"Brooklyn\",\n      COUNDIST &gt;= 49 & COUNDIST &lt;= 51 ~ \"Staten Island\",\n      TRUE ~ NA_character_\n    )\n  )\n\n# Choose species column\nspecies_col &lt;- if (\"spc_common\" %in% names(trees_with_boro)) {\n  \"spc_common\"\n} else if (\"genusspecies\" %in% names(trees_with_boro)) {\n  \"genusspecies\"\n} else {\n  NA_character_\n}\n\nspecies_col\n\n[1] \"genusspecies\"\n\n\n\nif (is.na(species_col)) {\n  manhattan_top_species &lt;- tibble(\n    note = \"No species column available in this dataset.\"\n  )\n} else {\n  manhattan_top_species &lt;- trees_with_boro |&gt;\n    filter(Borough == \"Manhattan\") |&gt;\n    sf::st_drop_geometry() |&gt;\n    count(.data[[species_col]], sort = TRUE) |&gt;\n    slice(1)\n}\n\nmanhattan_top_species\n\n                                                genusspecies   n\n1 Gleditsia triacanthos var. inermis - Thornless honeylocust 399\n\n\nAnswer (Q4): In Manhattan, the most common tree species (by count in our joined data) is:\nGleditsia triacanthos var. inermis - Thornless honeylocust."
  },
  {
    "objectID": "mp03.html#species-of-the-tree-closest-to-baruchs-campus",
    "href": "mp03.html#species-of-the-tree-closest-to-baruchs-campus",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "4.6 4.6 Species of the Tree Closest to Baruch’s Campus",
    "text": "4.6 4.6 Species of the Tree Closest to Baruch’s Campus\n\nnew_st_point &lt;- function(lat, lon){\n  sf::st_sfc(sf::st_point(c(lon, lat))) |&gt;\n    sf::st_set_crs(\"WGS84\")\n}\n\n# Approximate coordinates for Baruch College (Newman Vertical Campus)\nbaruch_point &lt;- new_st_point(lat = 40.7403, lon = -73.9837)\n\nclosest_tree &lt;- trees_with_districts |&gt;\n  mutate(distance_m = as.numeric(sf::st_distance(geometry, baruch_point))) |&gt;\n  arrange(distance_m) |&gt;\n  slice(1) |&gt;\n  sf::st_drop_geometry()\n\nclosest_tree\n\n  tpcondition stumpdiameter riskratingdate riskrating objectid\n1        Good          &lt;NA&gt;           &lt;NA&gt;       &lt;NA&gt;   386684\n                              globalid tpstructure\n1 8998DD59-D798-4200-8AFC-39ADD925F620     Retired\n                 plantingspaceglobalid         createddate dbh planteddate\n1 78FDD794-694E-429F-9C0D-1444792CC67F 2015-08-11 14:43:00   9        &lt;NA&gt;\n          updateddate\n1 2018-08-16 18:28:38\n                                                genusspecies COUNDIST\n1 Gleditsia triacanthos var. inermis - Thornless honeylocust        2\n  shape_leng shape_area area_m2 distance_m\n1   43018.81   57068955 5295436   109.4842\n\n\nAnswer (Q5): The tree closest to Baruch’s campus is of species\nGleditsia triacanthos var. inermis - Thornless honeylocust,\nand is approximately 109.5 meters from Baruch."
  },
  {
    "objectID": "mp03.html#project-overview",
    "href": "mp03.html#project-overview",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "5.1 Project Overview",
    "text": "5.1 Project Overview\nI propose the District 25 Tree Renewal & Safety Initiative, a targeted program to remove hazardous or dead street trees and replace them with new, resilient species in Jackson Heights and Elmhurst. The goal is to improve public safety, expand shade coverage, and strengthen the long-term health of the street-tree canopy in a dense, transit-dependent neighborhood."
  },
  {
    "objectID": "mp03.html#quantitative-scope",
    "href": "mp03.html#quantitative-scope",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "5.2 Quantitative Scope",
    "text": "5.2 Quantitative Scope\nUsing the observed distribution of tree conditions in our sample of NYC street trees, this project aims to:\n\nRemove 150–200 dead or severely declining trees (tpcondition == “Dead”) in District 25.\n\nPlant 250 new trees along key corridors such as Roosevelt Ave, Broadway, and 37th Ave.\n\nReplace 75 existing stumps with new plantings in residential and commercial blocks.\n\nConduct health assessments on ~300 older trees near schools, playgrounds, and bus stops to reduce future safety risks.\n\nThese targets are sized to make a visible impact within one or two planting cycles while remaining feasible for the Parks Department."
  },
  {
    "objectID": "mp03.html#visual-focus-on-district-25",
    "href": "mp03.html#visual-focus-on-district-25",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "5.3 Visual Focus on District 25",
    "text": "5.3 Visual Focus on District 25\nThe zoomed-in map from Task 2 shows the distribution of trees within District 25, highlighting clusters of dead or declining trees near major commercial streets and transit hubs. This spatial pattern supports a geographically focused intervention instead of a citywide, diffuse approach."
  },
  {
    "objectID": "mp03.html#why-district-25-comparative-argument",
    "href": "mp03.html#why-district-25-comparative-argument",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "5.4 Why District 25? (Comparative Argument)",
    "text": "5.4 Why District 25? (Comparative Argument)\nUsing the district-level summary from Task 4, we compare District 25 to three nearby Queens districts (20, 26, and 29):\n\nDistrict 25 has a high total tree count but also a higher fraction of dead trees than these neighboring districts.\n\nSome districts (e.g., 20 or 26) may have higher tree density, but District 25 combines substantial tree density with elevated mortality, creating both safety concerns and gaps in canopy quality.\n\nDistrict 25 serves a dense, immigrant-heavy, walk-dependent population, so improvements in shade, safety, and visual quality have outsized benefits for everyday life.\n\nThe bar chart comparing tree density and dead-tree fraction across these four districts (from Task 4) visually supports the claim that District 25 is a high-need and high-impact target for additional investment."
  },
  {
    "objectID": "mp03.html#supporting-visualizations",
    "href": "mp03.html#supporting-visualizations",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "5.5 Supporting Visualizations",
    "text": "5.5 Supporting Visualizations\nThis proposal is supported by:\n\nA zoomed-in map of District 25 (Task 2), showing where trees—and especially problematic trees—are located.\n\nA non-map graphic (Task 4 density/dead-fraction comparison plot) comparing District 25 to Districts 20, 26, and 29.\n\nOptionally, a second map comparing District 25 with another Queens district to highlight differences in dead-tree clustering or canopy gaps."
  },
  {
    "objectID": "mp03.html#conclusion",
    "href": "mp03.html#conclusion",
    "title": "Mini-Project #03: NYC Street Trees and Council Districts",
    "section": "5.6 Conclusion",
    "text": "5.6 Conclusion\nThe District 25 Tree Renewal & Safety Initiative uses NYC Open Data to identify where additional tree funding will have the greatest effect. By removing hazardous trees, planting new ones in priority corridors, and focusing on a dense and diverse community, this project delivers clear safety, environmental, and equity benefits while making efficient use of Parks Department resources."
  }
]